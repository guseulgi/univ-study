# 운영체제란

대표적인 시스템 소프트웨어

## 운영체제의 역할

1. 자원 관리로 컴퓨터 시스템을 효율적으로 운영하는 것

- 하드웨어 자원
- 소프트웨어 자원

2. 사용자 지원
   운영체제는 사용자가 내린 명령을 해석하여 실행하며 사용자와 하드웨어 사이의 매개체 역할을 하면서 사용자에게 편의성을 제공

## 모드

1. 커널 모드
   하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드
1. 일체형 커널
   운영체제의 모든 서비스가 커널 내에 포함된 커널
1. 마이크로커널
   운영체제 요소의 대부분을 커널 외부로 분리하여 커널 내부에는 메모리 관리, 프로세스 간 통신, 멀티태스킹 등 최소한 요소만 남겨 놓은 커널

1. 사용자 모드(보호 모드)
   하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 없는 모드

- 커널 모드에서는 운영체제만 동작하므로 응용 프로그램은 사용자 모드에서만 동작한다
- 시스템 호출: 응용 프로그램이 하드웨어에 대한 제어가 필요한 경우 운영체제에 서비스를 요청하는 메커니즘

## 운영체제의 구성

1. 프로세스 관리자

- CPU를 할당하기 위한 스케줄을 결정
- 프로세스의 상태를 관리

2. 메모리 관리자

- 메모리 할당 및 회수
- 운영체제가 직접 사용하는 메모리 공간에 응용 프로그램의 프로세스가 접근하지 못하도록 해야함

3. 장치 관리자

- 컴퓨터 시스템의 모든 장치를 관리

4. 파일 관리자

- 프로그램 파일과 데이터 파일을 관리
- 저장장치의 공간과 파일의 생성, 수정 등의 접근 제한도 관리

## 운영체제의 유형

1. 일괄처리 운영체제
   작업을 모아서 순서대로 처리하는 방식

2. 시분할 운영체제
   사용자의 프로그램을 한번에 조금씩 수행하여 여러 프로그램이 동시에 실행되는 것과 비슷한 효과를 내는 방식
   요청한 시점부터 반응이 시작되는 시점까지의 소요시간을 의미하는 응답시간이 일괄처리 운영체제보다 크게 단축됨

3. 실시간 운영체제
   원하는 시간 내에 프로그램의 결과를 얻을 수 있는 운영체제
   즉 처리기한을 맞추는 것이 중요한 우선순위가 높은 작업을 우선 처리할 수 있는 기법 활용

4. 분산 운영체제
   네트워크를 통해 다른 컴퓨터 시스템의 자원을 이용하는 것이 자신의 컴퓨터 시스템에 있는 자원을 이용하는 것처럼 가능하도록 함

---

# 프로세스

실행 중인 프로그램

- 프로그램은 디스크 내 파일로 존재하는 동작하지 않는 정적이며 수동적인 개체
- 프로세스는 프로그램을 실행시킨 것으로 운영체제로부터 프로그램이 동작을 하는데 필요한 CPU, 메모리, 입출력장치, 파일 등의 자원을 할당받아 동작을 시작한 것, 능동적인 개체
- 하나의 메모리 구조를 갖고 그 안의 코드 영역에 대해 하나의 제어 흐름을 가짐 -> 코드 영역, 정적 데이터 영역, 스택 영역, 힙 영역
- 프로그램 카운터가 가리키는 명령을 처리하는데 하나의 프로세스는 하나의 PC만 유지하므로 제어 흐름을 하나만 갖기 때문에 기본적으로 다중 처리가 불가능하다는 특징이 있다.

## 프로세스의 구성

- 메모리 구조
- 코드 영역: 프로그램 자체
- 데이터 영역
- 정적 데이터: 상수, 전역변수
- 스택: 지역변수, 매개변수
- 힙: 동적
- 프로세스 제어 블록(PCB): 프로세스의 정보를 보관

- PID: 프로세스 식별자
- PC(프로그램 카운터): 다음에 실행할 명령의 주소
- 상태
- 레지스터
- 프로세스 우선순위
- 메모리 관리 정보: 프로세스가 저장된 주소와 가상 메모리의 실주소의 사상 정보 등
  운영체제는 보통 여러 프로세스를 동시에 관리하며 번갈아 실행시키게 된다. 실행 중이던 프로세스의 정보를 PCB에 저장한 후 나중에 이 프로세스를 다시 실행하게 되면 프로세스 제어 블록에 저장된 정보를 이용하여 이어서 실행한다.

## 프로세스 상태 관리

1. 생성: 처음 작업이 주어진 상태로 프로세스 제어 블록을 생성하고 작업 큐에 넣는다.
2. 준비: 프로세스의 메모리 구조가 생성되어 CPU 할당을 기다리는 상태로 준비 큐에 머물다가 CPU를 할당받으면 실행 상태로 전이된다.
3. 실행: 프로세스가 처리되는 상태, CPU를 할당하는 과정을 디스패치라고 한다.

- 스케줄러가 준비 큐에서 다른 프로세스를 선택하게 되면 실행 상태의 프로세스는 CPU를 회수당하고 준비 상태로 전이된다.
- 실행 상태 프로세스가 입출력을 요구하는 작업이나 페이지 교환을 요구하는 작업을 만나면 대기 상태로 전이된다. (이러한 작업은 상대적으로 오랜 시간이 걸리기 때문에 CPU를 다른 프로세스에 할당하여 활용하기 위함)

4. 대기: 프로세스가 I/O 작업이 끝날 때까지 특정 자원을 할당 받을 때까지 보류되는 상태
5. 종료: 프로세스가 더 이상 실행되지 않도록 끝난 상태

## 부모 프로세스/자식 프로세스

한 프로세스가 다른 프로세스를 생성하는 방법 -> 프로세스 생성 시스템 호출

1. 부모 프로세스: 시스템 호출을 하는 프로세스
2. 자식 프로세스: 시스템 호출을 통해 새로 생성된 프로세스

- UNIX, Linux

  - fork() 시스템 호출을 통해 부모 프로세스의 복제본인 자식 프로세스 생성 (부모 프로세스의 메모리 구조와 동일)
  - exec() 을 사용하면 자식 프로세스가 부모 프로세스와 다른 프로그램을 실행함

- Windows
  - CreateProcess() 시스템 호출 사용, 이는 처음부터 새로운 프로그램으로 자식 프로세스를 생성

## 프로세스 종료

- 일반적인 경우: 프로세스의 마지막 명령이 실행을 마쳐 모든 처리를 완료하고 정상적으로 종료
- 부모 프로세스가 자식 프로세스의 번호를 이용하여 프로세스 종료 시스템 호출로 종료
- 부모 프로세스가 종료되는 경우 운영체제에 의해 자식 프로세스들이 모두 종료

다만 자식 프로세스가 종료되어 자원이 회수되더라도 자식 프로세스의 프로세스 제어 블록(PCB)은 부모 프로세스가 결과를 받을 때까지 사라지지 않고 유지 된다.

---

# 쓰레드

프로세스 내에서 다중 처리를 위해 제안된 개념
(자원 소유의 단위는 프로세스, 디스패칭의 단위는 쓰레드)

- 쓰레드마다 프로그램 카운터(PC)가 있어 쓰레드별로 디스패칭이 가능 (+레지스터, 스택)
- 각 쓰레드는 실행에 필요한 최소한의 정보만 가짐 (그 외 정보는 프로세스에 두고 다른 쓰레드와 공유)
- 쓰레드 또한 프로세스처럼 생성, 준비, 실행, 대기, 종료상태를 가짐

---

# 프로세스 스케줄링

1. 상위단계 스케줄링(장기 스케줄링)
   시스템에 들어와 작업 큐에 있는 작업을 선택하여 프로세스를 생성한 뒤 프로세스 준비 큐에 전달
   - 입출력 중심 작업/연산 중심 작업을 균형있게 선택하도록 작업순서 결정
2. 중간단계 스케줄링(중기 스케줄링)
   프로세스를 일시적으로 메모리에서 제거하여 중지시키거나 중지된 프로세스에 다시 메모리를 할당하여 활성화시켜 시스템에 대한 단기적인 부하를 조절하는 역할
   - 시스템이 과부하되는 경우 메모리에서 어떤 프로세스를 제거해야 시스템의 부하가 줄어들지를 결정하여 실제로 중지시켜준다
3. 하위단계 스케줄링(단기 스케줄링)
   준비큐에 있는 프로세스를 선택하여 사용 가능한 CPU를 할당하는 역할

## 스케줄링의 목표

1. 공정성: 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 하는 것
2. 균형성: 시스템의 자원들이 충분히 활용될 수 있게 하는 것

### 목표 기준

1. 처리량(throughput): 주어진 시간에 처리한 프로세스 수
2. 반환시간(turnaround time): 프로세스 생성 시점부터 종료 시점까지의 소요시간
3. 응답시간(response time): 요청한 시점부터 반응이 시작되는 시점까지의 소요시간
4. 대기시간(waiting time): 프로세스가 종료될 때까지 준비큐에 기다린 시간의 합

### 일괄처리 운영체제 목표

처리량의 극대화, 반환시간의 최소화, CPU 활용의 극대화

### 시분할 운영체제 목표

빠른 응답시간, 과다한 대기 시간 방지

### 실시간 운영체제 목표

처리기한 맞추기

## 스케줄링 정책(하위단계 스케줄링)

1. 선점 스케줄링 정책

- 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식
- 높은 우선순위의 프로세스를 우선 처리해야 하는 경우 유용
- 컨텍스트 스위칭이 일어나며 오버헤드 발생
  - 컨텍스트란 CPU의 모든 레지스터와 운영체제에 따라 요구되는 프로세스의 상태
  - 컨텍스트 스위칭은 CPU가 현재 실행하고 있는 프로세스의 문맥을 프로세스 제어 블록에 저장하고 다른 프로세스의 프로세스 제어 블록으로부터 문맥을 복원하는 작업

2. 비선점 스케줄링 정책

- 실행 중인 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식
- CPU를 할당받아 실행이 시작된 프로세스는 대기/종료상태로 전이될 때까지 계속 실행상태에 있게 된다

## 스케줄링 평가 기준

1. 평균대기시간: 각 프로세스가 수행이 완료될 때까지 준비큐에서 기다리는 시간의 합의 평균값
2. 평균반환시간: 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요시간의 평균값
   - 프로세스 생성 시간과 대기상태에서의 시간도 모두 포함

## 스케줄링 알고리즘

1. 비선점 방식

   1. FCFS 스케줄링
      프로세스는 준비 큐에 도착한 순서에 따라 디스패치되며 한 프로세스가 CPU를 차지하면 그 프로세스의 수행이 완료된 후 다음 프로세스가 CPU를 차지하고 수행된다

      - 프로세스들의 도착순서에 따라 평균반환시간이 크게 변함
      - 우선순위에 따른 프로세스를 처리하는 방법이 최근 사용되는데, 그 중에서도 우선순위가 같은 경우 FCFS를 적용

   2. SJF 스케줄링 (Shortest Job First)
      준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하여 실행

      - CPU 사이클이 미리 주어져야만 적용 가능 (미리 예상 불가)
      - 실행예정시간의 길이를 사용자 추정에 의존
      - 비선점이므로 새로 들어온 짧은 작업이 실행 중인 긴 작업을 기다리게 되기도 하므로 시분할 운영체제나 실시간 운영체제는 적합하지 않음

   3. HRN 스케줄링 (Highest Response Ratio Next)
      준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치하여 실행
      - 응답비율 = (대기시간+예상실행시간) / 예상실행시간
      - 응답비율은 예상실행시간이 짧고 대기시간이 길수록 커짐, 즉 모든 프로세스가 동시에 준비 큐에 들어온다면 예상실행시간이 가장 짧은 프로세스가 선택되고 예상실행시간이 모두 동일한 프로세스지만 준비큐에 들어온 시각이 모두 다르다면 대기시간이 가장 긴 프로세스가 선택됨

2. 선점 방식

   1. SRT 스케줄링 (Shortest Remaining Time)
      준비 큐에서 기다리는 프로세스 중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치하여 실행

      - 실행예정시간의 길이를 사용자 추정에 의존
      - 실행되는 각 프로세스의 실행시간을 추적하여 각 프로세스가 서비스를 받은 시간을 기록해야 하며, 선점을 위한 컨텍스트 스위칭도 해야 하므로 오버헤드가 SJF보다 크다

   2. RR 스케줄링 (Round Robin)
      프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량(시간각격)에 의해 실행을 제한

      - 시분할 운영체제에 적합
      - 시간 할당량을 어떻게 정하느냐에 따라 성능이 크게 달라진다
      - 프로세스가 한 번에 처리할 양을 처리할 수 있는 정도가 적당

   3. 다단계 피드백 큐 스케줄링
      입출력 중심인 프로세스와 연산 중심인 프로세스의 특성에 따라 서로 다른 시간 할당량을 부여
      - n 개의 단계가 있는 경우, 각 단계마다 하나씩의 준비큐가 존재하고 단계가 커질수록 시간 할당량은 커지는 형태
      - 하나의 단계에서 디스패치가 일어나면 다른 단계에선 디스패치 불가
      - 연산 위주의 프로세스는 시간 할당량 안에 종료되지 못하고 점점 단계가 커지고, 입출력 위주의 프로세스는 시간 할당량보다 짧은 실행이 유지되어 작은 단계를 유지한다

---

# 병행 프로세스

## 병행성

여러 개의 프로세스나 쓰레드가 동시에 수행되는 시스템의 특성

## CPU 개수

- 인터리빙 방식: CPU 1개에서 병행 프로세스가 실행되는 경우
  - 한순간에 하나의 프로세스가 실행
- 병렬처리 방식: 여러 개의 CPU(멀티프로세서) 시스템
  - 메모리 구조에 따라 실행되는 형태가 차이남
  - 강결합 시스템에서는 여러 CPU가 하나의 기억장치를 공유 (master/slave 환경, SMP-Symmetric MultiProcessing)
  - 약결합 시스템에서는 2개 이상의 독립된 컴퓨터 시스템이 네트워크로 서로 연결된 형태 즉 각 시스템은 자신의 운영체제와 기억장치를 가지고 독자적으로 운영
  - 시스템 간 통신을 위해 메시지 전달이나 원격 프로시저 호출(IPC) 사용

## 독립 프로세스

수행 중인 다른 프로세스에 영향을 주지 않고 받지도 않는 프로세스

- 자신이 사용하는 데이터를 다른 프로세스와 공유 X
- 결정적
- 재생 가능
  => 다른 프로세스의 영향을 받지 않으므로 입력 데이터만 동일하다면 실행결과는 항상 동일

## 협력 프로세스

수행 중인 다른 프로세스와 영향을 주고받으며 동작하는 프로세스

- 다른 프로세스와 데이터와 상태를 공유
- 비결정적
- 재생 불가
  => 다른 프로세스의 영향을 받을 수 있으므로 입력 데이터가 동일하더라도 실행 결과가 달라질 수 있음

---

# 병행성 문제

## 상호 배제

2개 이상의 프로세스가 동시에 임계영역을 수행하지 못하도록 하는 것

### 임계영역

2개의 프로세스가 동시에 사용하면 안되는 공유자원을 액세스하는 프로그램 코드 영역

## 동기화

2개 이상의 프로세스에 대한 처리순서를 결정하는 것

## 프로세스 간 통신 (IPC)

프로레스들이 데이터를 공유하기 위해 반드시 필요한 것

1. 변수 사용
2. 메시지 송수신

---

# 세마포어

상호배제와 동기화 문제를 해결하기 위한 도구

- 정수형 공용변수
- 사용 가능한 자원의 수, 잠김이나 풀림의 상태값 등의 초기화 필요
- P, V연산의 기본연산만 사용, 해당 연산은 인터럽트 되지 않고 하나의 단위로 처리됨

"""
void P (semaphore s) {
if (s > 0) s--;
else 현재 프로세스를 대기시킴;
}

void V (semaphore s) {
if (대기 중인 프로세스 없음) s++;
else 대기 중인 프로세스 1개 진행;
}
"""

## 상호배제 해결

한 프로세스가 임계영역을 수행 중이라면 다른 프로세스는 임계영역에 진입해서 안되며, 임계영역을 수행 중이던 프로세스가 임계영역에서 벗어나면 대기 중인 프로세스 중 하나는 새로이 임계영역을 수행해야 한다.

- 진입영역 -> P 연산
- 해제영역 -> V 연산
- 세마포어 초기값 1: 수행 시작 가능 여부

## 동기화 해결

A 프로세스가 S1를 수행한 뒤 B 프로세스 S2 를 수행하도록 동기화 하려면 S2 앞에 P 연산을 두고 S1 뒤에 V 연산을 두어 동기화할 수 있다.

- 세마포어 초기값 0: S1이 아직 수행되지 않음을 의미

---

# 병행 프로세스

## 생산자-소비자 문제 (유한 버퍼 문제)

두 협력 프로세스 사이 버퍼를 두고 한쪽 프로세스는 데이터를 넣고, 다른 프로세스는 데이터를 꺼내는 상황을 다루는 문제

## 생산자-소비자 문제 조건

1. 버퍼에 여러 프로세스가 동시에 접근 불가
2. 버퍼의 크기가 유한함
   => 상호배제와 동기화가 필요

## 세마포어를 이용한 해결

- mutex = 1 => 상호배제
  - 생산자가 버퍼에 데이터를 넣는 부분과 소비자가 버퍼에서 데이터를 꺼내는 부분은 임계영역이 된다
- empty = n (버퍼 수) => 동기화
  - 버퍼가 가득 찼을 때, 버퍼에 존재하는 빈 공간의 개수를 의미
  - 생산자가 데이터를 생산하더라도 소비자가 버퍼에서 데이터를 꺼낸 후에야 버퍼에 데이터를 넣을 수 있다
- full = 0 => 동기화
  - 버퍼가 빈 경우, 데이터의 개수를 의미
  - 소비자가 사용할 데이터가 없다면 생산자가 버퍼에 데이터를 넣은 후에야 소비자가 버퍼에서 데이터를 꺼낼 수 있다

---

# 판독기-기록기 문제

여러 협력 프로세스가 파일 같은 공유자원을 사이에 두고 데이터를 쓰거나 데이터를 읽는 상황을 다루는 문제

## 판독기-기록기 문제의 구체적인 조건

1. 기록기가 공유자원에 데이터를 쓰는 중에 다른 기록기나 판독기는 공유자원에 접근할 수 없다 => 상호배제 필요
2. 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있다

## 제1판독기-기록기 문제

판독기가 공유자원에 접근 중이라면 기록기보다 판독기에 우선순위를 주는 것

- 대기 중인 기록기가 있든 없든 새로운 판독기는 즉시 공유자원에 접근할 수 있다
- 기록기가 기아상태에 빠질 수 있다
  - 기아상태: 프로세스가 필요한 자원을 할당받지 못하고 계속적으로 대기하게 되는 상황

## 제2판독기-기록기 문제

판독기가 공유자원에 접근 중이라면 판독기보다 기록기 우선순위를 주는 것

- 대기 중인 기록기가 있으면 새로운 판독기는 두번째 조건에도 불구하고 공유자원에 접근할 수 없다
- 기록기의 기아상태를 방지하지만 판독기의 병행성이 떨어지거나 판독기가 기아상태에 빠질 수 있다

## 세마포어를 이용한 해결

1. 제1판독기-기록기 문제

   - wrt = 1 (세마포어)

     - 기록기에 대한 상호배제
     - 기록기가 공유자원에 데이터를 쓰는 부분은 다른 기록기가 쓰거나 판독기가 읽는 부분과 동시에 수행될 수 없으므로 임계영역이다
     - 판독기가 공유자원에서 데이터를 읽는 부분은 기록기가 쓰는 부분과 동시에 수행될 수 없으므로 임계영역이다

   - rcount = 0 (일반 변수)
     - 하나의 판독기가 임계영역을 수행 중일 때 다른 판독기도 임계영역을 수행할 수 있어야 하므로 일반 변수 rcount 를 두어 동시에 공유자원의 데이터를 읽는 판독기의 개수를 유지
     - rcount 가 1이상이 되면 공유자원을 읽는 판독기가 이미 있다는 것이므로 상호배제가 되지 않도록 P 연산을 생략한다
     - 임계영역 수행이 끝나고 rcount 를 1 줄였을 때 여전히 0보다 크다면 다른 판독기가 있다는 의미이므로 V 연산을 수행하지 않도록 한다
     - rcount 를 변화하고 확인하는 작업은 다른 판독기에 방해를 받으면 안되므로 임계영역으로 보고 mutex 를 사용하여 상호배제 처리 해준다
   - mutex = 1 (세마포어)
     - rcount 의 상호배제

   """ 기록기의 코드
   P(wrt)
   공유자원에 쓰기
   V(wrt)
   """

   """ 판독기의 코드
   P(mutex)
   rcount = rcount + 1
   if (rcount == 1) then P(wrt)
   V(mutex)
   공유자원 읽기
   P(mutex)
   rcount = rcount - 1
   if (rcount == 0) then V(wrt)
   V(mutex)
   """

2. 제2판독기-기록기 문제

   - rd = 1
   - wrt = 1
   - mutex1 = 1
   - mutex2 = 1
   - mutex3 = 1
   - rcount = 0
   - wcount = 0

   """ 기록기 코드
   P(mutex2)
   wcount = wcount + 1
   if (wcount == 1) then P(rd)
   V(mutex2)
   P(wrt)
   공유자원에 쓰기
   V(wrt)
   P(mutex2)
   wcount = wcount - 1
   if (wcount == 0) then V(rd)
   V(mutex2)
   """

   """ 판독기 코드
   P(mutex3)
   P(rd)
   P(mutex1)
   rcount = rcount + 1
   if (rcount == 1) then P(wrt)
   V(mutex1)
   V(rd)
   V(mutex3)
   공유자원 읽기
   P(mutex1)
   rcount = rcount - 1
   if (rcount == 0) then V(wrt)
   V(mutex1)
   """

# 프로세스 간 통신 (InterProcess Communication IPC)

병행 프로세스가 데이터를 서로 공유하는 방법

1. 공유 메모리 방법
   협력 프로세스가 동일한 변수(공유 자원)를 사용하여 데이터를 서로 공유하는 방법

   - 메모리에 직접 접근하여 대량의 데이터를 쓰거나 읽기에 적합
   - 빠른 속도
   - 상호배제나 동기화 등 문제를 응용 프로그래머가 책임

2. 메시지 전달 방법
   협력 프로세스가 메시지를 주고 받으면서 데이터를 서로 공유하는 방법

   - 커널모드에서 작동하는 send, receive 연산 사용
   - 시스템 호출을 사용하므로 소량의 데이터를 주고 받는데 적절
   - 운영체제가 상호배제나 동기화 문제에 책임

   * 통신 링크
     두 프로세스가 서로 메시지를 주고 받을 때 두 프로세스 사이에는 통신 링크가 존재

     - 링크의 방향성은 단방향/양방향 가능
     - 하나의 링크가 두 개의 프로세스만 연결하도록 하거나 여러 프로세스를 연결하도록 할 수 도 있음
     - 링크의 용량은 버퍼(큐)에 보관할 수 있는 메시지 수

   1. 직접통신
      두 프로세스가 직접 서로를 지정하여 메시지를 주고 받는 방법

   - 송신자는 send 연산에 수신자를 명시
   - 수신자는 receive 연산에 송신자를 명시
   - 직접통신은 서로를 지정한 두 프로세스 사이에 오직 하나의 통신 링크가 자동으로 설정됨
   - 양방향성
   - 송수신자가 각각 상대를 직접 명시하는 경우 대칭형 주소 지정, 수신자가 송신자를 미리 지정하지 않고 메시지를 받을 때 송신자 이름도 받는 경우 비대칭형 주소 지정

   2. 간접통신
      통신을 원하는 프로세스들 사이에 우편함을 두고 이를 통해 메시지를 주고 받는 방법

   - 송신자는 send 연산세 수신자 대신 우편함을 명시
   - 수신자는 receive 연산에 송신자 대신 우편함을 명시
   - 두 프로세스 사이 통신 링크는 같은 우편함을 이용하는 경우 설정된다
   - 송신자가 여럿이고 수신자가 하나라면 우편함이 수신자에 속한 경우로 단방향, 수신 프로세스가 종료되면 우편함도 사라짐
   - 수신자가 여럿인 경우 우편함이 운영체제에 소속되어 한순간에 하나의 수신자만 우편함에서 메시지를 받을 수 있도록 운영체제가 수신자를 관리 -> 송신자와 수신자의 역할이 바뀔수도 있으므로 통신 링크는 양방향

---

프로세스가 자원을 사용하는 절차는

1. 프로세스가 필요한 자원이 있으면 요구
2. 자원을 획득한 후 사용 (획득하지 못하면 대기)
3. 사용이 끝나면 획득했던 자원을 해제하고 반납

# 교착상태

여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있기에 결과적으로 어느 쪽도 영원히 진행하지 못하는 상태
-> 관련된 모든 프로세스가 자원획득의 가능성 없이 무한히 대기 상태인 것

- 기아 상태: 관련된 프로세스의 일부가 자원획득의 가능성은 있으나 계속적으로 대기 상태인 것

## 교착상태의 필요조건

1. 상호배제 조건
   - 프로세스가 자원에 대한 배타적인 통제권을 요구하는 조건
   - 적어도 하나 이상의 자원은 여러 프로세스에 의해 동시에 사용될 수 없음
   - 필요로 하는 자원을 다른 프로세스가 점유하고 있으면 반드시 대기하게 된다
2. 점유대기 조건
   - 프로세스가 이미 한 자원을 할방받아 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는 또 다른 자원을 요청하여 해제되기를 기다리는 상황
3. 비선점 조건
   - 프로세스에 할당된 자원은 프로세스가 사용을 마치고 스스로 반환하기 전 해제되지 않음을 의미
   - 할당된 자원은 타의에 의해서 해제 되지 않는다
4. 환형대기 조건
   - 프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 상황

## 자원할당 그래프

교착상태를 명확하게 표현하기 위해 자원할당 그래프를 이용

- V: 정점의 집합
  - P: n 개의 프로세스 {p1, p2, ... pn} => 원
  - R: m개의 단위자원 {r1, r2, ... rm} => 사각형 (단위 자원의 개수를 숫자로 표시)
- E: 방향 있는 간선의 집합
  - Q: 프로세스 p가 자원 r을 요구한다(요구간선)
  - S: 자원 r가 프로세스 p에 할당된다(할당간선)

1. 가용한 단위자원이 존재하면 요구간선은 할당간선으로 바뀐다
2. 자원이 해제될 때 이 할당간선은 삭제된다

3. 교착상태의 환형대기 조건을 만족하는 것은 사이클이 존재한다
4. 교착상태의 점유대기 조건을 만족하는 것은 한 프로세스에 할당간선과 요구간선을 연결하는 것이다
5. 교착상태의 비선점 조건을 만족하는 것은 요구간선으로 표현되는 것이다
6. 교착상태의 상호배제 조건을 만족하는 것은 할당간선으로 표현되는 것이다

7. 자원할당 그래프의 기본 성질로 점유대기, 비선점, 상호배제 조건으로 만족되므로 사이클의 유무로 교착상태의 발생 가능성을 확인할 수 있다

## 교착상태 예방

1. 상호배제 제거

- 공유할 수 있는 자원은 상호배제가 필요하지 않으므로 교착상태를 유발하지 않으나 공유할 수 없는 자원은 상호배제를 따른다
- 그러므로 상호배제 조건을 제거하여 교착상태를 예방하는 것은 불가능

2. 점유대기 제거

- 자원을 점유했을 때 대기하지 않도록 하거나 대기할 때 자원을 점유하고 있지 않도록 한다
- 자원을 점유했을 때 대기하는 상황이 발생하지 않도록 필요한 모든 자원을 처음에 한꺼번에 요구하여 할당받으면 된다
- 자원을 미리 점유하게 되어 실제 자원이 필요한 시점까지 아무도 그 자원을 활용하지 못해 자원이용률이 낮아질 수 있으므로 기아상태에 빠질 수 있다
- 점유 도중 해제할 수 없는 자원에는 적용할 수 없다

3. 비선점 제거

- 자원의 특성에 따라 선점 가능하도록 만들 수 없다
- 차선책으로 자원을 점유한 프로세스가 다른 자원을 요구할 때 대기가 발생한다면 할당받았던 자원을 모두 해제하여 다른 프로세스가 비선점 조건으로 대기할 가능성을 줄인다

4. 환형대기 제거

- 모든 자원에 일련번호를 지정하고 프로세스 자원을 요구할 때 일련번호를 기준으로 항상 오름차순이 되도록 요구하는 것이 환형대기를 제거할 수 있다
- 프로세스가 자원을 요구할 때 그보다 일련번호가 큰 자원은 점유하고 있지 않도록 하는 방법 또한 환형대기를 제거할 수 있다
- 점유대기 중인 프로세스는 항상 점유하고 있는 자원의 일련번호보다 대기 중인 자원의 일련번호가 클수밖에 없다
- 프로세스마다 자원의 요구순서가 다를 수 있으므로 자원의 일련번호 설정에 어려움이 존재

## 교착상태 회피
