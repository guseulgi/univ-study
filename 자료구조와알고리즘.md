# 알고리즘

주어진 문제를 해결하기 위한 일련의 단계적인 처리 과정

- 일상적인 언어
- 순서도
- 의사 코드
- 프로그래밍 코드

# 알고리즘의 조건

1. 입출력: 0개 이상의 입력을 받아서 하나 이상의 출력을 생성해야 함
2. 명확성: 각 단계는 모호하지 않고 단순 명확해야 함
3. 유한성: 한정된 수의 단계를 거친 후 반드시 끝나야 함
4. 유효성: 모든 명령은 컴퓨터에서 수행할 수 있어야 함

---

# 알고리즘 설계

주어진 문제의 입출력 조건과 처리 조건 등을 고려하여 문제를 분석하고 이를 바탕으로 알고리즘을 설계

문제를 푸는 방법과 절차를 찾는 것에만 국한하지 않고 해결안의 정확성과 효율성을 분석하는 과정도 함께 이루어짐

문제와 함께 주어진 조건 등의 차이에 따라 문제해결에 적용되는 알고리즘이 달라질 수 있기에 알고리즘 설계에 있어 모든 문제나 대부분 문제에서 적용할 수 있는 범용적인 개념의 알고리즘 설계기법은 존재하지 않음

# 알고리즘 설계기법

1. 욕심쟁이 방법 (greedy)
   선택 과정을 통해 해를 찾는데 전후 단계의 선택과 상관없이 단계마다 정해진 기준에 따라 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적 전략

- 희망적: 각 단계에서 전후 단계의 선택에 대해선 아무런 고려 없이 단지 현재 상태에서만 만족하는 최적해만을 선택하기에 국부적인 최적해가 항상 전체적인 최적해를 만들지 못할 수 있음을 의미
- 적용 범위가 제한적이라 해를 구할 수 없는 문제가 있을 수 있음
  ex. 거스름돈 문제, 배낭 문제, 최소 신장 트리 구하기(크루스칼, 프림 알고리즘), 최단 경로 구하기(데이크스트라 알고리즘)

* 거스름돈 문제
  가게에서 고객에게 돌려줄 거스름돈이 T원일 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제로 거스름돈의 액수를 초과하지 않으면서 단순히 액면가가 큰 동전부터 최대한 뽑아서 거스름돈을 만드는게 요지이다.

ex. 거스름돈이 780원일 때 고객에게 돌려줄 동전의 최소 개수(500, 100, 50, 10)
500 x 1 + 100 x 2 + 50 x 1 + 10 x 3
위의 결과로 거스름돈은 총 7개의 동전이 됨

하지만 650원을 500, 120, 100, 50, 10 동전으로 거슬러주고자 할 때 그리디 알고리즘으로는
500 x 1 + 120 x 1 + 10 x 3 으로 총 5개의 동전이 필요하지만
최적해는 500 x 1 + 100 x 1 + 50 x 1 로 총 3개의 동전을 사용하는 방법이다.

- 배낭 문제1

  - 배낭의 용량: M -> 10
  - 물체의 개수 n -> 4
  - 물체1의 이익과 무게(p1, w1) -> 18, 3
  - 물체2의 이익과 무게(p2, w2) -> 15, 5
  - 물체3의 이익과 무게(p3, w3) -> 12, 3
  - 물체4의 이익과 무게(p4, w4) -> 25, 4

  최대 용량 M인 하나의 배낭에 넣을 수 있는 n개의 물체가 있고 각 물체에는 무게 w와 그 물체를 배낭에 넣었을 때 얻을 수 있는 이익 p이 부여되어 있다고 가정한다. 배낭의 용량을 초과하지 않으면서 배낭에 들어있는 물체들의 이익의 합이 최대가 되도록 물체를 넣을 방법을 찾는 문제이다.
  여기서 물체를 쪼개서 넣을 수 있는가 없는가가 구분될 수 있는데 물체를 쪼개서 넣을 수 있다고 가정하고 생각한다.

  배낭의 용량을 조금 차지하면서 이익이 많은 물체부터 배낭에 욕심을 부려 최대한 넣는 과정을 반복한다. 물체를 통째로 넣을 수 없다면 남은 배낭의 용량에 맞게 물체를 쪼개어 넣어준다.

  각 단계의 선택 기준, 어떤 물체를 넣을 것인지 정하는 것이 중요하다. 물체를 쪼갤 수 있으므로 물체의 이익을 취하기보단 단위 무게당 이익을 계산한 뒤 최대가 되는 물체부터 배낭에 넣으면 최적해를 구할 수 있다.

  p/w => (18/3, 15/5, 12/3, 25/4) => 6, 3, 4, 6.25
  단위 무게당 이익

  위의 결과에 따라 물체 4, 1, 3, 2 순으로 배낭에 넣어준다.

  1. 물체 4 => 10-4 = 6
  2. 물체 1 => 6-3 => 3
  3. 물체 3 => 3-3 => 0
     -- 물체 2는 용량 부족으로 넣을 수 없다.
     즉 얻을 수 있는 최대 이익은 25+18+12 = 55가 된다.

- 배낭 문제2 - 물체를 쪼갤 수 없는 경우
  M = 10, n = 4
  p/w => (15/3, 20/5, 9/3, 14/4) => 5, 4, 3, 3.5
  물체를 넣는 순서: 물체1 -> 2 -> 4 -> 3

  1. 물체 1 => 10-3 = 7
  2. 물체 2 => 7-5 = 2
     물체를 쪼갤 수 있었다면 물체 4를 반으로 쪼개어 넣으면 되지만, 쪼갤 수 없다고 가정한 경우이므로 용량 2를 남기고 여기서 끝내게 된다.
     최대 이익은 15+20 = 35로 생각할 수 있지만 이것은 최적해가 아니다.
     실제 최대 이익은 물체 1, 3, 4를 넣어서 얻을 수 있는 15+9+14 = 38이 된다.

  \*\* 쪼갤 수 없는 유형의 배낭 문제를 0/1 배낭 문제라고 하며 이 문제는 그리디 방법으론 해결이 불가능하고 NP-완전 문제로 해결할 수 있다.

2. 분할 정복 (divide and conquer)
   순환적으로 문제를 푸는 하향식 접근 방법

주어진 문제의 입력을 더이상 나눌 수 없을 때까지 2개 이상의 작은 문제들로 순환적으로 분할하고, 분할된 작은 문제들을 각각 해결한 뒤 이들의 해를 결합하여 원래의 문제의 해를 구하는 방식이다.

각 순환 호출마다 분할, 정복, 결합의 세 가지 작업이 이루어진다.

- 분할: 주어진 문제의 입력을 여러 개의 작은 문제로 분할
- 정복: 작은 문제들을 순환적으로 분할
- 결합: 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구함

문제를 작게 쪼개는 것이 중요하고 작게 쪼개진 문제들은 원래의 문제에 비해 입력의 크기만 작아졌을 뿐 문제 자체는 원래 문제와 동일하고 서로 독립적이기에 각각의 작은 문제를 다시 순환적으로 분할하고 그 결과를 통합할 수 있게 된다.
ex. 퀵 정렬, 합병 정렬, 이진 탐색 등

- ex. 순환 알고리즘을 사용한 배열에서 탐색 키를 찾는 이진 탐색 과정
  A[] = {10, 15, 20, 25, 30, 35, 40, 45, 50}

key = 20
Left = 0
Right = 8
Mid = floor((Right+Left)/2)

A[Mid] = 30
key 보다 A[Mid]를 비교했을 때 key가 더 작으므로 배열의 왼쪽 절반에 해당하는 부분 배열로 대상을 줄여서 이진 탐색을 순환 호출한다.

A[] = {10, 15, 20, 25}
Left = 0
Right = 3
Mid = floor((Right+Left)/2)

A[Mid] = 15
key 가 A[Mid] 보다 크므로 배열의 오른쪽에 해당하는 부분 배열을 사용해서 이진 탐색을 순환 호출한다.

A[] = {20, 25}
Left = 2
Right = 3
Mid = floor((Right+Left)/2)

A[Mid] = 20
탐색 키 key와 A[Mid] 값이 같으므로 Mid = 2를 반환하고 탐색을 마친다.

위 과정은 분할정복 방법의 세 단계에 대응시켜보면

- 분할: 입력 크기가 n인 배열 중 가운데 원소를 기준으로 크기가 2/n인 왼쪽 부분배열과 오른쪽 부분배열로 분할
- 정복: 탐색 키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출하고 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출한다. 이진 탐색을 수행할 때마다 한쪽 부분배열은 대상에서 제외되므로 탐색 범위가 절반씩 줄어든다.
- 결합: 부분배열에 대해 이진 탐색의 결과가 직접 반환되므로 결과를 결합하는 과정은 필요 없음

3. 동적 프로그래밍 (dynamic programming)
   입력 크기가 가장 작은 부분 문제부터 해를 구하여 저장해 놓고 이를 이용하여 입력 크기가 보다 큰 문제의 해를 점진적으로 만들어 가는 상향식 접근 방법

- 작은 문제들은 분할정복 방법과 달리 독립적일 필요가 없음
- 한번 사용한 작은 문제의 해가 다음에 또 사용될 수 있으므로 이를 저장해두고 필요할 때마다 바로 사용

ex. 최솟값, 최댓값을 구하는 최적화 문제에 주로 사용, 모든 정점 쌍 간의 최단 경로를 구하는 플로이드 알고리즘

# 알고리즘 분석

## 정확성 분석

정확한 알고리즘이라면 유효한 입력이 주어졌을 때 유한 시간 내 정확한 결과를 생성해야 함.
수학적 기법을 사용하여 알고리즘이 예상한 대로 수행되는지에 대해 증명하는 과정

## 효율성 분석

알고리즘을 수행하는데 얼마나 많은 컴퓨터 자원이 필요한가를 평가하는 것 (주변장치, 수행 시간, 메모리 등)

주로 알고리즘을 수행하는데 시간적으로 얼마나 걸리는지와 공간적으로 얼마만큼의 메모리가 사용되는지 분석

1. 시간 복잡도
   알고리즘의 수행시간

- 실행부터 완료까지 걸리는 실제 수행시간의 측정을 통해 계산
- 사용하는 컴퓨터의 속도, 구현에 사용되는 프로그래밍 언어의 종류, 프로그램 작성법, 컴파일러 효율성 등 실행 환경에 따라 달라지므로 일반성이 없음
- 객관적인 측정방법으론 연산의 수행 횟수를 세는 방법을 사용하여 계산함
- 수행 횟수는 보통 하나의 문장으로 표현되므로 알고리즘의 각 문장이 수행되는 횟수의 합이 됨

2. 공간 복잡도
   알고리즘 수행에 필요한 총 메모리의 양

- 컴파일 과정에서 고정적으로 결정되는 정적인 공간과 실행 과정에서 동적 할당이나 함수 호출 등을 통해 동적으로 결정되는 공간

알고리즘 수행시간은 입력 크기와 입력 데이터의 상태에 따라 결과가 달라질 수 있고 입력 크기가 커질수록 그에 따라 수행시간은 당연히 증가하게 된다. 그래서 수행시간을 단순히 특정 입력 크기에 대한 단위 연산의 수행 횟수의 합으로 표현하기보단 입력 크기의 함수로 표현하게 된다.

알고리즘의 수행시간에 있어 입력되는 데이터의 상태에 따라 달라지기도 하는데, 정렬을 수행하는 경우 입력 데이터가 우연히 정렬된 상태로 제공되는 경우와 입력이 무작위 순서를 갖는 경우의 수행시간이 달라질 수 있다. 따라서 가장 이상적인 접근 방법은 가능한 모든 입력 상태에 대해 각각의 수행시간을 계산하고 이들의 평균/가중 평균을 취하는 것이다.
하지만 일반적으로 최선의 데이터 상태가 되는 것은 어려우므로 최악 수행시간을 알고리즘의 시간 복잡도의 척도로 많이 사용하는 것이다. 즉 어떠한 상태의 입력이 주어져도 이를 초과하는 수행시간은 걸리지 않는다는 것을 보장하므로 성능을 비교하기 용이하다.

### 수행시간 계산 예시

```
SumAverage(A[], n)
입력: A[0..n-1], n : 입력 배열과 데이터의 개수
출력: 데이터의 합과 평균
{
sum = 0; -> 1회
i = 0; -> 1회
while (i < n) { -> n+1회
sum = sum + A[i]; -> n회
i = i + 1; -> n회
}
average = sum / n; -> 1회
print average, sum; -> 1회
}
```

n은 입력 배열의 크기인 입력 데이터의 개수이다. 각 줄로 표현된 각 문장이 수행되는 횟수를 계산한 뒤 이를 모두 더한 값인 3n + 5 이 수행시간이 된다.

```
DoubleIteration(n)
입력 n : 반복 횟수
출력: 이중 루프의 총 반복 횟수
{
count = 0; -> 1회
for (i=0; i<n; i++) { -> n+1회
for (j=0;j<n;j++) -> n+1회
count ++; -> n^2회
}
print count; -> 1회
}
```

수행시간은 n^2+2n+4 가 된다.

## 점근성능

입력 크기가 커질수록 이에 비례하여 알고리즘의 수행시간은 증가하며 성능차이도 확연해진다. 그래서 입력 크기(n)가 작은 경우가 아닌 큰 상황을 전제로 알고리즘의 논리구조를 파악하여 성능을 분석하는 것이 바람직하다. 점근성능이란 입력 크기 n이 무한히 커짐으로써 결정되는 성능을 의미한다.

수행시간은 an+b, an^2+bn+c 등과 같은 다항식으로 표현되는데 상수 a,b,c 들은 연산의 종류와 알고리즘이 수행되는 컴퓨터 속도에 좌우되는 값으로 상수를 무시하고 입력 크기 n에 대한 차수만 고려하는 것이 일반적이다.

그리고 낮은 차수의 항들은 무시하고 최고차항만을 이용하여 수행시간을 더욱 간결히 표현해준다. 결국 점근성능으로 표현한다는 것은 수행시간의 다항식 함수에서 입력 크기가 충분히 커짐에 따라 함숫값에 가장 큰 영향을 미치는 차수를 찾는 것으로 다항식 함수에서 최고차항만을 계수 없이 취해서 단순화시킨 형태로 성능을 표현한다.

이처럼 점근성능을 표기하는 방법은 주로 빅오 표기, 빅오메가, 빅세타 표기를 사용한다.

1. 빅오 O()
   어떤 양의 상수 c,n0이 존재하여 모든 n>=n0에 대해
   f(n) <= c∙g(n)을 만족하면 f(n)=O(g(n))

- 점근 상한, 최악 수행시간

2. 빅오메가 Ω()
   어떤 양의 상수 c,n0 이 존재하여 모든 n>=n0에 대해
   f(n) >= c∙g(n)을 만족하면 f(n)=Ω(g(n))

   - 점근 하한, 최선의 수행시간

3. 빅세타 ⍬()
   어떤 양의 상수 c1,c2,n0 이 존재하여 모든 n>=n0에 대해
   c1∙g(n) <= f(n) <= c2∙g(n) 를 만족할 때
   -> f(n) = O(g(n)) = Ω(g(n)) 이면 f(n) = ⍬(g(n)) 이다.

   - 점근적 상한과 하한을 동시에 가지므로써 다른 표기법보다 성능을 정밀하게 나타낼 수 있음

ex. f(n) = 3n+3 / g(n) = n일 때 f(n)을 점근 표기법으로 나타내면,
c=5, n0=2 이면 n>=2 인 모든 n에 대해 f(n) <= 5∙g(n) 를 만족하므로 f(n) = O(g(n)) 인 O(n)이 된다.
c=3, n0=1 이면 n>=1 인 모든 n에 대해 f(n) >= 3∙g(n) 를 만족하므로 f(n) = Ω(g(n)) 인 Ω(n)이 된다.
f(n) = O(n) 이면서 Ω(n)이므로 f(n)=⍬(n)이기도 하다.

알고리즘의 시간 복잡도는 일반적으로 빅오 표기법을 사용한다.
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)

---

# 순환 (recursion)

어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법
순환적으로 정의된 문제나 자료구조를 다루는 프로그램에 적합

ex. 팩토리얼
n!을 정의하는데 (n-1)!이 사용된다. 이러한 경우 순환적이라 한다.

```
int factorial(int n) {
if (n <=1 ) return (1);
else return (n \* factorial(n-1));
}
```

즉, fatorial(3) 의 경우 = 3 \* factorial(2) = 3 \* 2 \* factorial(1) = 3 \* 2 \* 1 이 된다.

- 꼬리순환
  순환 호출이 위처럼 n \* factorial(n-1) 순환 함수의 맨 끝에서 이루어지는 형태의 순환으로 알고리즘은 쉽게 반복적인 형태로 변환이 가능하다는 특징이 있다. 하지만 그 반대인 factorial(n-1) \* n 인 머리 순환의 경우나 하노이탑(아래에 있음) 문제 같이 자기 자신을 여러 자리에서 호출하는 경우 쉽게 반복적인 코드로 바꿀 수 없다. 그러므로 꼬리 순환으로 나타낼 수 있다면 머리 순환 보다 우선하여 작성한다.

## 순환 호출의 내부적인 구현

프로그램에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일하다. 복귀 주소가 시스템 스택에 저장되고 호출되는 함수를 위한 매개 변수와 지역 변수를 스택으로부터 할당받는다. 이러한 함수를 위한 시스템 스택에서 공간을 활성 레코드라고 한다.
만약 호출된 함수가 자기 자신이라면 자기 자신의 시작 위치로 점프하고 호출된 함수가 끝나게 되면 시스템 스택에서 복귀 주소를 추출하여 호출한 함수로 되돌아가게 된다.

- 활성 레코드
  활성 레코드는 스택에 저장되며 매개 변수의 값, 함수 호출이 끝나고 복귀할 주소, 지역변수 등을 저장한다.

대부분의 프로그래밍 언어에선 순환을 지원하지만 Fortran, cobol, basic 에선 순환이 불가능하다. 이는 함수 호출마다 새로운 지역 변수를 만들지 못하면 이전 호출과 구분할 수 없기 때문이다.

## 순환 알고리즘의 구조

1. 자기 자신을 순환적으로 호출하는 부분 + 일부 문제를 해결
2. 순환 호출을 멈출 수 있는 조건 부분 -> 멈출 수 없는 부분이 없다면 시스템 스택을 다 사용할 때까지 순환적으로 호출되다가 overflow 오류를 발생시킨다.

## 순환과 반복

순환 코드의 단점은 실행 시간에 있어 가독성이 증대되고 코딩도 더 간단한 이점에도 불구하고 순환을 반복으로 변경하여 알고리즘을 작성하는 경우가 있다.

## 순환의 원리

주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 방법을 분할 정복이라고 한다. 순환 호출이 일어날 때마다 일부 문제를 해결하므로 문제의 크기가 점점 작아지고 문제의 크기가 점점 작아지면 풀기가 쉬워지고 결국 아주 풀기 쉬운 문제가 된다.

순환은 문제의 정의가 순환적으로 되어 있는 경우 유리한 방법으로 팩토리얼 뿐만 아니라, 피보나치 수열, 이항 계수 계산, 이진 트리 알고리즘, 이진 탐색, 하노이탑 문제 등을 해결할 때 사용하는 것이 자연스럽다.

## 순환 알고리즘의 성능

반복과 순환 알고리즘은 시간 복잡도가 같지만 순환 호출의 경우 여분의 기억 공간이 더 필요하고 함수를 호추하기 위한 함수의 파라미터들을 스택에 저장하는 것과 같은 사전 작업이 훨씬더 필요하다. 그렇기 때문에 위에서 말했다시피 실행 시간도 더 걸리는 것이다.

즉 순환 알고리즘은 이해하기 쉽다는 것과 쉽게 프로그래밍할 수 있다는 장점이 있지만 수행 시간과 기억 공간의 사용에 있어선 비효율적인 경우가 많다.

ex. 순환 알고리즘이 반복 알고리즘보다 속도가 빠른 예 - 거듭제곱 값 계산

```
// 반복 알고리즘 사용
double slow_power(double x, int n) {
int i;
double r = 1.0;
for (i=0; i<n; i++)
r = r\*x;
return (r);
}

// 순환 알고리즘 사용
double power(double x, int n) {
if n = 0
than return 1;
else if n%2==0
than return power(x^2, n/2);
else
than return x\*power(x^2, (n-1)/2);}
```

순환 알고리즘을 사용하는 경우, x^n = (x^2)^(n/2) 의 공식을 사용하여 n이 짝수인 경우와 홀수인 경우를 나눠서 계산해주는 것이다. 해당 함수에서도 문제의 크기가 줄어든다.

power(2, 10) -> power(4, 5) -> power(16, 2) -> power(256, 1) -> power(66536, 0)
1024 <- 1024 <- 256 <- 256 <- 1

이처럼 순환 호출을 할 때마다 문제의 크기가 절반으로 줄어들기 때문에 거듭제곱에선 반복보다 순환이 빠른 결과가 나오는 것이다. 이는 약 k번의 순환 호출이 일어나게 되어 n=2^k이므로 로그를 취하면 log2n = k 이므로 전체 연산의 개수는 k = log2n에 비례하고 시간 복잡도는 O(log2n)이 되는 것이다.

ex. 피보나치 수열
앞의 두 개의 숫자를 더해서 뒤의 숫자를 만드는 수열이다.
0, 1, 1, 2, 3, 5, 8, ...

```
int fib(int n) {
if (n == 0) return 0;
else if (n == 1) return 1;
else return (fib(n-1) + fib(n-2));
}
```

위처럼 피보나치 수열은 순환 알고리즘으로 간단하게 나타낼 수 있다. 하지만 순환되는 자기 자신의 함수가 순환이 깊어질수록 점점 중복되기 때문에 비효율적이다.

예를 들어 fib(6)을 구하기 위해서 fib() 함수가 25번이나 호출된다.

- fib(6) -> fib(4), fib(5)
  - fib(4) -> fib(2), fib(3)
    - fib(2) -> fib(1), fib(0)
    - fib(3) -> fib(2), fib(1)
  - fib(5) -> fib(4), fib(3) - fib(4) -> fib(3), fib(2)
    ...
    하나의 함수 호출로 두 개의 함수 호출로 나누어지므로 시간 복잡도는 O(n^2) 가 된다.

```
// 반복적인 피보나치 수열 계산 프로그램
int fib_iter(int n) {
if ( n <2 ) return n;
else {
int i, tmp, current = 1, last = 0;
for (i = 2; i <= n; i++) {
tmp = current;
current += last;
last = tmp;
}
return current;
}
}
```

fib_iter(3) -> i = 2일 때 tmp = 1, current = 1, last = 1 / i = 3일 때 tmp = 1, current = 2, last = 1 이므로 2가 된다. 이처럼 순환을 사용한 피보나치 수열과 달리 반복을 사용한 피보나치 수열은 일전에 계산된 값을 저장해두므로 시간 복잡도는 O(n) 이 된다.

ex. 하노이탑 문제
3개의 막대에 n개의 원판이 있다고 가정할 때 막대 A에 쌓여있는 원판 n개를 막대 C로 옮기되

1. 한 번에 하나의 원판만 이동
2. 맨 위에 있는 원판만 이동
3. 크기가 작은 원판 위에 큰 원판이 쌓일 수 없음
4. 중간의 막대를 임시적으로 사용할 수 있으나 위의 조건들을 지켜야 함

4가지의 조건을 지켜야 한다.

예를 들어 3개의 원판이 있는 경우

처음 상태: A(3) B(0) C(0)

1. A(2) B(0) C(1)
2. A(1) B(1) C(1)
3. A(1) B(2) C(0)
4. A(0) B(2) C(1)
5. A(1) B(1) C(1)
6. A(1) B(0) C(2)
7. A(0) B(0) C(3)
   의 총 7번으로 조건을 만족하며 원판을 옮길 수 있다.

더 나아가 n개의 원판이 있는 경우 순환적으로 생각하면 쉽게 해결이 가능하다. 순환에서는 순환이 일어날수록 문제의 크기, 즉 이동하여야 하는 원판의 개수가 줄어들어야 한다는 것이다. 문제를 나누어 생각해보면 n개의 원판이 A에 쌓여있는 경우 먼저 위에 쌓여 있는 n-1개의 원판을 B로 옮긴 다음 제일 밑에 있는 원판을 C로 옮긴다. 그리고 B에 있던 n-1개의 원판을 C로 옮겨주면 될 것이다. -> C를 임시버퍼로 사용해준다.

```
void hanoi_tower(int n, char from, char tmp, char to) {
if (n == 1) {
// from에서 to로 원판을 옮김
}
else {
// 1 from 의 맨 밑의 원판을 제외한 나머지 원판을 tmp로 옮김
hanoi_tower(n-1, from, to, tmp)

    // 2 from 에 있는 한 개의 원판을 to로 옮김

    // 3 tmp 원판들을 to로 옮김
    hanoi_tower(n-1, tmp, from, to)

}
}
```

원판의 개수가 1개일 때 이동횟수는 1
원판의 개수가 2개일 때 이동횟수는 3
원판의 개수가 3개일 때 이동횟수는 7
원판의 개수가 4개일 때 이동횟수는 15 ...
즉 원판의 개수가 n개 일 때 이동횟수는 f(n) = 2\*f(n-1)+1 이 된다. (2^n-1)

---

# 배열

여러 개의 동일한 데이터 타입의 데이터를 한번에 만들 때 사용된다. 가장 기본적인 배열의 특징은 <인덱스, 요소> 쌍의 집합이라는 것으로 인덱스가 주어지면 해당 요소가 대응하는 구조이다.

배열은 메모리의 연속된 위치에 구현되어 시작주소인 A[0]의 주소가 base 라면, A[1]은 base+1 \* sizeof(자료형), A[2]은 base+2 \* sizeof(자료형), ... A[n]은 base+n \* sizeof(자료형) 형식으로 할당된다.

배열의 이름은 포인터와 같은 역할을 하므로 함수의 매개변수로서 배열을 받아서 배열에 대한 처리가 이루어지면 원래의 배열이 수정되므로 유의해야 한다.

## 다항식과 배열

다항식 y = a1x^i1 + a2x^i2 + ... 가 있을 때 a1은 계수, i1은 차수라고 부르며 그 중 가장 큰 차수를 그 다항식의 차수라고 부른다.

프로그램 안에서 다항식을 표현하기 위한 배열에는 2가지 방법이 있다.

1. 다항식의 모든 차수에 대한 계수값을 배열에 저장
   10x^5 + 6x + 3 이면, coef = [10, 0, 0, 0, 6, 3] 으로 저장해주는 것이다. 하나의 다항식에서 배열 coef 와 가장 큰 차수인 다항식의 차수 값을 구조체로 묶어준다.

```
#define MAX_DEGREE 101
typedef struct {
  int degree;
  float coef[MAX_DEGREE];
} polynomial;
```

다항식에서 같은 차수의 계수를 쉽고 빠르게 찾을 수 있다는 장점이 있지만 이 방식은 다항식의 대부분 항의 계수가 0인 희소 다항식의 경우 공간의 낭비가 심하다는 단점이 있다.

```
// 다항식의 덧셈
polynomial poly add1(polynomial A, polynomial B) {
  polynomial C; // 결과 다항식
  int Apos = 0, Bpos = 0, Cpos = 0; 배열 인덱스 변수
  int degree_a = A.degree;
  int degree_b = B.degree;
  C.degress = MAX(A.degree, B.degree);

  while (Apos <= A.degress && Bpos <= B.degree) {
    if (degree_a > degree_b) {
      C.coef[Cpos++] = A.coef[Apos++];
      degree_a--;
    }
    else if ( degree_a == degree_b ) {
      C.coef[Cpos++] = A.coef[Apos++] + B.coef[Bpos++];
      degree_a--; degree_b--;
    }
    else {
      C.coef[Cpos++] = B.coef[Bpos++];
      degree_b--;
    }
  }
  return C;
}
```

최고차항부터 배열에 차례대로 저장되어 있어 구조체A,B의 coef 배열을 스캔하며 차수가 큰 항을 구조체 C로 이동한다. 차수가 같으면 구조체 A, B의 coef 배열값을 더하여 C 의 coef에 대입하고 두 개 다항식 모두 차수가 최고차항에서 0까지 존재하므로 while 루프가 끝나면 모든 항들이 처리되는 것이 보장된다.

2. (계수, 차수) 형식의 구조체 배열에 저장
   공간을 절약하기 위해 다항식에서 0이 아닌 항만을 하나의 전역 배열에 저장하는 방법한다.

다만 이 방법은 하나의 다항식이 시작되고 끝나는 위치를 가리키는 변수들을 관리해야 한다. 그리고 차수도 저장해야 하기 때문에 다항식에 따라 계수만 저장하는 첫번째 방식보다 공간을 더 많이 필요할 수 있다. 또한 다항식의 덧셈을 비롯한 연산들의 구현이 첫 번째 방법보다 좀더 어려워진다.

```
#define MAX_TERMS 101
struct {
    float coef; // 계수
    int expon; // 지수
} terms[MAX_TERMS] = { {8,3}, {7,1}, {1,0}, {10,3}, {3,2}, {1,0} };
// A = 8x^3 + 7x^1 + 1, 즉 As = 0, Ae = 2
// B = 10x^3 + 3x^2 +1 Bs = 3, Be = 5 라고 가정할 때

int avail = 6; // terms의 크기

// 두 개의 정수를 비교하는 함수
char compare(int a, int b) {
  if (a>b) return '>';
  else if (a==b) return '=';
  else return '<';
}

// 새로운 항을 다항식에 추가하는 함수
void attach(float coef, int expon) {
  if(avail > MAX_TERMS) {
    fprint('항의 개수가 너무 많음');
    exit(1);
  }

  terms[avail].coef = coef;
  terms[avail++].expon=expon;
}

// 두 번째 다항식의 덧셈 함수
void poly_add2(int As, int Ae, int Bs, int Be, int *Cs, int *Ce) {
  float tempcoef;
  *Cs = avail;

  while (As <= Ae && Bs <= Be) {
    switch(compare(terms[As].expon, terms[Bs].expon)) {
      case '>':
        attach(terms[As].coef, terms[Bs].expon);
        As++; break;
      case '=':
        tempcoef = terms[As].coef + terms[Bs].coef;
        if (tempcoef)
          attach(tempcoef, terms[As].expon);
        As++; Bs++; break;
      case '<':
        attach(terms[Bs].coef, terms[Bs.expon]);
        Bs++; break;
    }
  }

  for (;As<=Ae;As++)
    attach(terms[As].coef, terms[As].expon);

  for (;Bs<=Be;Bs++)
    attach(terms[Bs].coef, terms[Bs].expon);

  *Ce = avail -1;
}
```

As, Ae 는 다항식 A의 처음과 마지막을 가리키며 Bs, Be는 다항식 B의 처음과 끝을 가리킨다. Cs, Ce 는 덧셈의 결과로 생성되는 다항식의 처음과 끝을 가리키며 attach 함수는 해당 항목을 배열의 terms의 빈 공간에 더하는 함수이다.

## 배열과 희소 행렬

```
#define MAX_ROWS 100
#define MAX_COLS 100
int matrix[MAX_ROWS][MAX_COLS];
```

희소 행렬은 0으로 된 항들이 많은 경우로 메모리의 낭비가 심하므로 배열을 이용하되 0이 아닌 요소들만 나타내어 0이 아닌 요소들만 나타내는 방법이 있다. 즉 0이 아닌 요소만을 (행, 열, 값)으로 표시하는 것이다. 아래처럼 희소 행렬을 배열로 나타내는 방법에는 두 가지가 있다.

1. 전통적인 2차원 배열로 나타낸 희소 행렬
2. (행, 열, 값) 형태의 배열로 표현한 희소 행렬

행렬의 덧셈 연산을 구현하는 경우 방법 1에서는 해당되는 배열의 요소들을 단순히 더하면 된다.

```
void sparse_matrix_add1(int A[ROWS][COLS], int B[ROWS][COLS], int C[ROWS][COLS]) {
  int r, c;
  for (r=0; r<ROWS; r++) {
    for (c=0; c<COLS; c++) {
      C[r][c] = A[r][c] + B[r][c];
    }
  }
}
```

하지만 방법 2로 덧셈 연산을 하려면 복잡해진다. 우선 하나의 요소를 나타내는 구조체의 배열이 필요하여 하나의 희소 행렬에 대한 하나의 1차원 구조체 배열과 행의 개수, 열의 개수가 필요하다.
2차원 배열의 각 요소에 위->아래, 왼쪽->오른쪽으로 순차적인 번호를 매겨서 이들 번호가 일치하면 같은 위치의 요소라고 판단하여 덧셈 결과 또한 이들 번호순으로 저장해준다.
index_number(row, col) = row\*(열의개수) + col 를 사용하여 번호를 계산하여 배열의 각 요소들의 인덱스 번호가 일치하면 요소들을 더해주는 과정을 수행하게 된다. 어느 한 쪽의 배열이 끝나게 되면 남아있는 요소들을 한꺼번에 C로 이동하여 프로그램을 마친다.

```
typedef struct {
  int row;
  int col;
  int value;
} element;

typedef struct SparseMatrix {
  element data[MAX_TERMS];
  int rows; // 행의 개수
  int cols; // 열의 개수
  int terms; // 항의 개수
} SparseMatrix;

void sparse_matrix_add2(SparseMatrix a, SparseMatrix b) {
  SparseMatrix c;
  int ca = 0, cb = 0, cc = 0;

  if (a.rows != b.rows || a.cols != b.cols) {
    fprint("행렬 크기 에러");
    exit(1);
  }
  c.rows = a.rows;
  c.cols = a.cols;
  c.terms = 0;

  while (ca < a.terms && cb < b.terms) {
    int inda = a.data[ca].row * a.cols + a.data[ca].col; // 각 항목의 순차적인 번호를 계산
    int indb = b.data[cb].row * b.cols + b.data[cb].col;

    if (inda < indb) {
      // a 배열 항목이 앞에 있으면
      c.data[cc++] = a.data[ca++];
    } else if (inda == indb) {
      // a, b가 같은 위치면
      if ((a.data[ca].value+b.data[cb].value) != 0) {
        c.data[cc].row = a.data[ca].row;
        c.data[cc].col = a.data[ca].col;
        c.data[cc++].value = a.data[ca++].value + b.data[cb++].value;
      } else {
        ca++;
        cb++;
      }
    } else {
      // b 배열 항목이 앞에 있으면
      c.data[cc++] = b.data[cb++];
    }
  }

  // 배열 a, b 에 남아있는 항들을 c로 옮김
  for (; ca < a.terms ;)
    c.data[cc++] = a.data[ca++];
  for (; cb < b.terms ;)
    c.data[cc++] = b.data[cb++];

  c.terms = cc;
  return c;
}
```

# 구조체

일반적인 객체는 여러 다른 타입들이 묶여있다. 같은 데이터의 모임인 배열과 달리 구조체는 타입이 다를 수 있는 데이터를 묶는 방법이다.

```
// 구조체 정의
struct 구조체명 {
  항목1;
  항목2; ...
}

struct 구조체명 변수명; // 구조체 변수 선언
```

```
typedef struct 구조체명 {
  항목들;
} 구조체 변수;
```

typedef 를 통해 구조체를 새로운 타입으로 정의 및 선언이 가능하다.

구조체 변수명 뒤에 항목 연산자인 . 을 사용하여 외부에서 항목들에 접근할 수 있다.

```
typedef struct person {
  char name[10];
  int age;
  float height;
} person;

main () {
  person a, b;
  b = a; // 가능

  if(a > b) printf('a가 b보다 나이가 많음'); // 컴파일 오류 발생

  //구조체 비교는 불가하므로 구조체 변수를 비교하기 위해선 직접 함수를 작성해야 한다.

  int compare(person a, person b) {
    if (a.age > b.age) return 1;
    else if (a.age == b.age) return 0;
    else return -1;
  }
  if (compare(a, b)) printf('a가 b보다 나이가 많음');
}
```

## 자체 참조 구조체

구성 요소 중에서 자기 자신을 가리키는 포인터가 한 개 이상 존재하는 구조체

- 연결 리스트나 트리에 많이 등장
- 항목의 개수를 미리 예측할 수 없는 경우 자체 참조 구조체로 정의해두고 동적으로 기억장소를 할당받아 이들을 포인터로 연결하여 자료 구조를 구성

```
typedef struct ListNode {
  char data[10];
  struct ListNode *link; // 자체 참조가 가능한 포인터
} ListNode;
```

## 구조체 배열

구조체를 요소로 하는 배열

```
typedef struct {
  int month;
  int date;
} BirthdayType;

typedef struct {
  char name[MAX_NAME];
  BirthdayType birthday;
} StudentType;

StudentType students[MAX_STUDENTS];

void main() {
  strcpy(students[0].name, "홍길동");
  students[0].birthday.month = 10;
  students[0].birthday.date = 28;
}
```

# 포인터

모든 변수는 주소를 가지고 있고 포인터 변수는 다른 변수의 주소를 가지고 있는 변수로, 곧 다른 변수를 가리킨다.
컴퓨터 메모리는 바이트로 구성되어 각 바이트마다 순차적으로 주소가 매겨져 있다.

```
char a = 'A';
char *p;
p = &a; // 변수의 주소를 &연산자를 사용하여 추출
*p = 'B'; // 포인터 변수가 가리키는 메모리 내용을 꺼내거나 변경하려면 *연산자 사용
```

이때 *p와 a가 동일한 메모리를 참조하게 되어 값만 같은 것이 아닌, 동일한 객체를 가리키므로 *p를 변경하면 a의 값도 변하게 된다는 점에 유의해야 한다.

## 함수 매개변수로서의 포인터

특정 변수를 가리키는 포인터가 함수의 매개 변수로 전달되면 그 포인터를 사용하여 함수 안에 변수의 값을 변경할 수 있고 그 결과는 함수 호출자에 영향을 준다.

```
void swap(int *px, int *py) {
  int tmp;
  tmp = *px;
  *px = *py;
  *py = tmp;
}
```

해당 함수는 매개 변수로 받는 두 값을 바꿔준다. 이처럼 함수가 하나 이상의 값을 반환해야 할 때 포인터를 사용한다.

```
typedef struct {
  int x;
  int y;
} PointType;

int get_line_parametert(PointType p1, PointType p2, float *slope, float *yintercept) {
  if (p1.x == p2.x) return -1;
  else {
    *slope = (float)(p2.y-p1.y)/(float)(p2.x-p1.x); // 기울기
    *yintercept = p1.y - (*slope)*p1.x; // y 절편
    return (0);
  }
}
```

배열의 이름은 배열의 시작 부분을 가리키는 포인터이므로 함수의 매개 변수로 배열이 전달되면 배열의 내용을 변경할 수 있었다. 하지만 실제로 컴파일러가 배열의 이름에 공간을 할당하지는 않기 때문에 배열의 이름이 있는 곳의 첫 번째 요소의 주소가 배열의 주소로 대치된다. 이렇게 메모리를 절약한다.

구조체의 멤버에 접근하는 -> 연산자를 사용하여 (\*포인터).멤버 형식은 포인터->멤버 형식으로 간단하게 사용할 수 있다.

```
struct {
  int i;
  float f;
} s, *ps;
ps = &s;
ps->i = 2; // (*ps).i = 2 와 동일
ps->f = 3.14; // (*ps).f = 3.14 와 동일
```

구조체도 함수의 매개 변수로 사용될 수 있기 때문에 구조체 자체를 매개변수로 넘기는 것은 부담이 크기 때문에 구조체의 주소만 옮겨지게 된다.

## 포인터의 포인터

포인터도 하나의 변수이므로 포인터의 포인터가 가능하다.

```
chr a;
chr *p; // 문자 포인터 선언
chr **pp; // 문자 포인터의 포인터 선언

a = 'A';
p = &a;
pp = &p;

void foo(int a) {}

void (*f)(int); // 함수의 주소를 담는 포인터 타입
f = foo;
f(10); // foo(10) 과 동일
(*f)(10); // f(10) 과 동일, 결국 foo(10) 과 동일
```

## 포인터 연산

포인터에 대한 연산은 보통 연산과 다르다. 포인터의 주소 값이 감소되고 증가되는 것이 아니라 포인터가 가리키는 객체의 앞뒤를 가리키게 된다.

```
int A[6], int *pi = NULL;
pi = &A[3];
printf(pi+1); //A[4]
printf(pi-1); //A[2]
```

```
p // 포인터
*p // 포인터가 가리키는 값
*p++ // 포인터가 가리키는 값을 가져온 다음, 포인터가 1개 증가
*p-- // 포인터가 가리키는 값을 가져온 다음, 포인터가 1개 감소
(*p)++ // 포인터가 가리키는 값을 증가
```

- 포인터가 어떤 값을 가리키고 있지 않을 땐 NULL 로 설정 권장
- 포인터가 초기화되기 전 포인터가 가리키는 곳에 자료를 저장하면 안됨

```
char *pi; // 초기화 전
*pi = 'E'; // X
```

- 포인터 타입 간 변환 시 명시적인 타입 변환을 사용해야 함

```
int *pi;
float *pf;
pf = (float *)pi; // 명시적 형변환
```

프로그램이 메모리를 할당받는 방법에는 정적 메모리 할당과 동적 메모리 할당이 있으며,
정적 메모리 할당은 프로그램의 시작 전 미리 정해진 크기의 메모리를 할당받는 것으로 실행 도중 크기가 변경될 수 없다. 그래서 주로 프로그램이 시작되기 전 미리 그 크기를 아는 경우에 사용된다. (배열 등)
간단하게 메모리 할당을 할 수 있지만 경우에 따라 비효율적일 수 있다. 프로그램이 처리해야 하는 입력의 크기를 미리 알 수 없기에 고정된 크기의 메모리를 할당하고 이는 더 큰 입력이 들어오면 처리하지 못하고 작은 입력이 들어오면 남은 메모리가 낭비되기 때문이다.

# 동적 메모리 할당

프로그램이 실행 도중 동적으로 메모리를 할당받는 것으로 프로그램에서 필요한 만큼의 메모리를 시스템으로부터 동적으로 할당받아서 사용하고 사용이 끝나면 시스템에 메모리를 반납한다. 필요한 만큼만 할당 받고 또 필요한 때에 사용하고 반납하기 때문에 효율적으로 메모리를 사용할 수 있다.

```
int *pi;
pi = (int *)malloc(sizeof(int)); // 동적 메모리 할당

free(pi);
```

주의할 점은 malloc 함수가 반환했던 포인터 값(pi)을 잊어버리면 안된다.

## void \*malloc(int size)

sizq에 해당하는 바이트만큼 메모리 블록을 할당한다. 새로운 메모리 블록의 시작주소(=포인터)를 반환하며, 반환되는 포인터의 타입은 void \*이므로 적절한 포인터로 타입 변환이 필요하다.

만약 메모리 확보가 불가능하면 NULL을 함수의 반환한다.

## void free(void \*ptr)

동적으로 할당되었던 메모리 블록을 시스템에 반납

## void \*calloc(int num, int size)

size 크기를 가진 배열 형식의 메모리를 num 개 할당
요소들은 0으로 초기화됨

## sizeof

변수나 타입의 크기를 바이트 단위의 숫자로 반환
구조체의 경우 접근 속도를 빠르게 하기 위한 패딩 바이트에 의해 크기가 예상과 다를 수 있음

동적으로 생성된 구조체는 포인터를 통해서만 접근할 수 있다.

```
struct Example {
  int number;
  char name[10];
};

void main() {
  struct Example *p;

  p = (strunc Example *)malloc(2*sizeof(strunc Example));
  if (p==NULL) {
    exit(1);
  }

  p->number = 1;
  strcpy(p->name, "Park");

  (p+1)->number = 2;
  strcpy((p+1)->name, "Kim");
  free(p);
}
```

---

# 리스트

집합에는 각 항목 간 순서 개념이 없으나 리스트에는 항목들 간 순서가 존재한다.

리스트의 연산은 아래와 같다.

- 새로운 항목을 리스트의 임의의 위치에 추가
- 기존의 항목을 리스트의 임의의 위치에서 삭제
- 모든 항목 삭제
- 기존 항목 대치
- 리스트가 특정한 항목을 가지고 있는지 확인
- 리스트가 특정 위치의 항목을 반환
- 리스트 안 항목의 개수 반환
- 리스트가 비었는지 꽉 찼는지 확인
- 리스트 안의 모든 항목을 표시
  보통 리스트를 사용할 때 항목들의 위치에 대해선 별로 신경쓰진 않지만 프로그램이 리스트를 사용할 땐 항목의 위치를 사용하는 것이 편리하고 정밀하게 연산을 기술할 수 있다.

## 리스트 추상 데이터타입

```
객체: n 개의 element형으로 구성된 순서 있는 컬렉션

연산
1. add_last(list, item)
2. add_first(list, item)
3. add(list, pos, item)
4. delete(list, pos)
5. clear(list)
6. replace(list, pos, item)
7. is_in_list(list, item)
8. get_entry(list, pos)
9. get_lenth(list)
10. is_empty(list)
11. is_full(list)
12. display(list)
```

## 리스트 구현

### 배열

배열로 리스트를 구현하면 가장 간단하게 구현할 수 있으나 그 크기가 고정되므로 넣을 수 있는 항목에 제한이 생긴다.
그리고 이미 저장된 요소들의 중간에 요소를 추가하게 되면 혹은 삭제하게 되면, 물리적으로 저장된 메모리의 위치를 이동하게 된다는 문제점도 발생한다. 이때 오버헤드가 발생하게 된다.

```
typedef int element;
typedef struct {
  element list[MAX_LIST_SIZE];  // 배열 정의
  int length;                   // 현재 배열에 저장된 자료들의 개수
} ArrayListType;
// 정적 또는 동적 메모리 할당으로 생성

void error(char *message) {
  fpirntf(stderr, "%s\n", message);
  exit(1);
}

void init(ArrayListType *L) {
  return L->length = 0; // 리스트 초기화, 길이를 0으로 만들어줌
}
```

```
// 리스트가 비어있으면 1 반환, 아니면 0 반환
int is_empty(ArrayListType *L) {
  return L->lengh == 0;
}

// 리스트가 가득 차 있으면 1 반환, 아니면 0 반환
int is_full(ArrayListType *L) {
  return L->lengh == MAX_LIST_SIZE;
}
```

```
void display(ArrayListType *L) {
  int i;
  for (i=0;i<L.length;i++) {
    printf("%d\n", L->list[i]);
  }
}
```

```
void add(ArrayListType *L, int position, element item) {
  // 리스트가 가득 차지 않고 / 넣어줄 포지션이 0보다 크거나 같고 / 최고 길이보다 작거나 같은 경우에만 삽입이 되어야함
  if (!is_full(L) && (position >=0) && (position <= L->length)) {
    int i;
    for (i=(L->length-1); i>=position; i--) {
      L->list[i+1] = L->list[i]; // 삽입해줄 위치를 비우기 위해 모든 값을 뒤로 밀어주기
    }

    L->list[position] = item; // 포지션에 element 를 넣어줌
    L->length++; // 총 길이를 늘려줌
  }
}
```

```
element delete(ArrayListType *L, int position) {
  int i;
  element item;

  if (position < 0|| position >= L->length) error("위치 오류"); // 삭제할 포지션 제약

  item = L->list[position]; // 빼줄 아이템 반환을 위해 미리 저장
  for (i=position; i<(L->length-1); i++) {
    L->list[i] = L->list[i+1]; // 앞선 데이터들을 하나씩 앞으로 당겨줌
  }
  L->length--; // 전체 리스트 길이를 줄임
  return item;
}
```

```
main() {
  ArrayListType list1; // 정적 생성
  ArrayListType *plist; // 동적 생성

  init(&list1);
  add(&list1, 0, 10);
  add(&list1, 0, 20);
  add(&list1, 0, 30);

  plist = (ArrayListType *)malloc(sizeof(ArrayListType));
  init(plist);
  add(plist, 0, 10);
  add(plist, 0, 20);
  add(plist, 0, 30);
  free(plist);
}
```

### 포인터, 연결 리스트

연결된 표현은 데이터와 링크로 구성되어 링크가 데이터들을 연결하는 역할을 한다. 이때 링크를 포인터로 구현해줄 수 있다.
이를 통해 데이터를 저장할 공간이 필요할 때마다 동적으로 공간을 만들어서 쉽게 추가할 수 있게 된다.

이러한 공간을 노드라고 부르며 연결 리스트는 노드들의 집합이며 이들은 데이터를 저장하고 있고 서로 연결되어 있다. 노드들은 메모리의 어떤 위치에나 있을 수 있으며(즉 노드들의 저장 위치 순서가 리스트상의 순서와 동일하지 않을 수 있다) 다른 노드에 가기 위해선 현재 노드가 가지고 있는 포인터를 이용하면 된다.
다만 연결 리스트에선 첫 번째 노드를 알아야만 전체 노드에 접근할 수 있으므로 첫 번째 노드를 가리키는 변수인 head pointer 를 변수로 둔다. 그리고 마지막 노드의 링크를 NULL로 표현해서 더이상 연결된 노드가 없음을 나타낸다.

연결 리스트를 사용하면 연속적인 기억 공간이 없어도 데이터를 저장하는 것이 가능하며 미리 기억 공간을 확보할 필요가 없이 필요할 때마다 노드를 동적으로 생성하여 연결하면 된다.
하지만 링크 필드를 위한 추가 공간이 필요함과 연산의 구현이나 사용법이 배열에 비해 복잡하다.

- 연결 리스트는 정적인 데이터보다는 변화가 심한 데이터에서 효과적인 방법임
  데이터들이 메모리 상에서 흩어져서 존재함

#### 단순 연결 리스트

하나의 방향으로만 연결되어 있음
마지막 노드의 링크 필드는 NULL 값을 가짐

```
typedef int element;
typedef struct ListNode {
  element data;             // 데이터 필드
  struct ListNode *link;    // 링크 필드 -> 현재 정의되고 있는 구조체를 가리키는 포인터
} ListNode;
```

```
ListNode *p1;
p1 = (ListNode *)malloc(sizeof(ListNode));
p1->data = 10;
p1->link = NULL;

ListNode *p2;
p2 = (ListNode *)malloc(sizeof(ListNode));
p2->data = 20;
p2->link = NULL;
p1->link = p2;

free(p1);
free(p2);
```

```
void insert_node(ListNode **phead, ListNode *p, ListNode *new_node) {
  if(*phead == NULL) {
    new_node->link=NULL;
    *phead=new_node
  } else if (p == NULL) {
    new_node->link = *phead;
    *phead = new_node;
  } else {
    new_node->link = p->link;
    p->link = new_node;
  }
}
```

```
void remove_node(ListNode **phead, ListNode *p, ListNode *removed) {
  if (p==NULL){
    *phead = (*phead)->link;
  } else {
    p->link=removed->link;
  }
free(removed);
}
```

```
// 반복적인 리스트 방문 알고리즘
void display(ListNode *head) {
  ListNode *p = head;
  while(p != NULL) {
    p = p->link;
  } // 연결 리스트의 끝에 도달할 때까지 반복
}

// 순환적인 리스트 탐색 알고리즘
void display_recur(ListNode *head) {
  ListNode *p = head;
  if (p!= NULL) {
    display_recur(p->link);
  }
}
```

순환 호출은 반복적인 방법보다 보통 실행 시간이 더 걸림.

```
ListNode *search(ListNode *head, int x) {
  ListNode *p;
  p = head;
  while( p!= NULL ) {
    if (p->datq == x) return p;
    p = p->link;
  }

  return p;
}
```

```
ListNode *concat(ListNode *head1, ListNode *head2) {
  ListNode *p;

  if (head1 == NULL) return head2;
  else if (head2 == NULL) return head1;
  else {
    p = head11;
    while (p->link != NULL) {
      p = p->link;
    }
    p->link = head2;
    return head1;
  }
}
```

```
ListNode *reverse(ListNode *head) {
  ListNode *p, *q, *r;
  p = head;
  q = NULL;

  while (p != NULL) {
    r = q;
    q = p;
    p = p->link;
    q->link = r;
  }
  return q;
}
```

포인터를 3개 사용하여 리스트를 순회하면서 링크의 방향을 역순으로 바꿀 수 있다. 새로운 연결 리스트를 만들지 않고 기존의 리스트 안에서 문제를 해결할 수 있다. 다만 미리 뒤의 노드를 알아놓아야 하므로 포인터를 추가로 사용하는 것이다.

- p: 아직 처리되지 않은 노드
- q: 현재 역순으로 만들 노드
- r: 이미 역순으로 변경된 노드
  즉 r은 q를, q는 p를 차례로 따라간다.

#### 원형 연결 리스트

하나의 방향으로만 연결되어 있으나 마지막 노드의 링크 필드가 첫 번째 노드를 가리킴
즉 마지막 노드의 링크 필드가 NULL이 아닌 첫 번째 노드의 주소가 되는 리스트이다.

한 노드에서 링크를 계속 따라가면 결국 모든 노드를 거칠 수 있으므로 다른 모든 노드로 접근이 가능하다.
노드의 삽입과 삭제가 단순 연결 리스트보다 용이하다.

하지만 탐색할 때 끝 노드를 찾기 어렵다는 단점이 있는데, 이는 p->link = head 를 가리키는 것을 찾으면 된다.
그러므로 단순 연결 리스트에서 리스트의 끝에 노드를 넣으려면 첫 번째 노드부터 링크를 따라서 노드의 개수만큼 진행한 뒤 삽입할 수 있지만 원형 연결 리스트에선 헤드 포인터가 마지막 노드를 가리키도록 구성하여 상수 시간 안에 리스트의 처음이나 끝에 노드를 삽입할 수 있다.

```
void insert_first (ListNode **phead, ListNode *node) {
  if (*phead == NULL) {
    *phead = node;
    node->link = node;
  }
  else {
    node -> link = (*phead)->link;
    (*phead)->link = node;
  }
}

void insert_last(ListNode **phead, ListNode *node) {
  if (*phead == NULL) {
    *phead = node;
    node->link = node;
  } else {
    node->link = (*phead)->link;
    (*phead)->link = node;
    *phead = node;
  }
}
```

새로운 노드의 링크인 node->link 가 첫 번째 노드를 가리키게 하고
다음 마지막 노드의 링크가 node를 가리키게 만들어준다.

#### 이중 연결 리스트

단순 연결 리스트에서는 어떤 노드에서 후속 노드를 찾기는 쉽지만 선행 노드를 찾으려면 헤드 포인터부터 시작해서 탐색해야 한다. 그러므로 특정 노드에서 양방향으로 자유롭게 움직일 필요가 있다면 각 노드마다 링크 필드가 앞뒤로 2개씩 존재하는 이중 연결 리스트를 사용해야 한다.

링크가 선행 노드, 후속 노드 양방향으로 존재하므로 검색 또한 양방향으로 가능하지만 공간을 많이 차지하고 코드가 복잡해진다는 단점이 있다.

헤드 포인터와 다른 헤드 노드를 별개로 추가하는데, 헤드 포인터는 리스트의 첫 번재 노드를 가리키는 포인터지만 헤드 노드는 데이터를 가지고 있지 않은 특별한 노드로 이중 연결 리스트에선 공백 상태일 때 헤드 노드만 존재하게 된다. 헤드 노드를 사용함으로써 삽입, 삭제가 간편해진다.

```
typedef int element;

typedef struct DlistNode {
  element data;
  struct DlistNode *llink;
  struct DlistNode *rlink;
} DlistNode;
```

위처럼 선행 노드와 후속 노드를 지정해주면 임의의 노드를 가리키는 포인터를 p 라고 했을 때,
p == p->llink->rlink == p->rlink->llink 의 관계가 항상 성립하게 된다.

```
void dinsert_node (DlistNode *before, DlistNode *new_node) {
  new_node->llink = before;
  new_node->rlink = before->rlink;

  before->rlink->llink = new_node;
  before->rlink = new_node;
}

void dremove_node (DlistNode *phead_node, DlistNode *removed) {
  if (removed == phead_node) return;

  removed->llink->rlink = removed->rlink;
  removed->rlink->llink = removed->llink;
  free(removed);
}
```

---

### 연결 리스트의 응용: 다항식

```
typedef struct ListNode {
  int coef;               // 계수
  int expon;              // 차수
  struct ListNode *link;  // 다음을 가리키는 포인터
} ListNode;
```

다항식이 연결 리스트로 표현되어 있으므로 포인터 변수p, q를 이용하여 다항식 A, B 항들을 따라 순회하면서 각 항을 더한다. 이 때 p, q가 가리키는 항의 지수에 따라 3가지 경우로 나누어 처리할 수 있다.

1. p.expon == q.expon
   두 계수를 더해서 0이 아니면 새로운 항을 만들어서 다항식 C에 추가한다.
   그리고 p, q는 모두 다음 항으로 이동한다.

2. p.expon < q.expon
   q가 가리키는 항을 새로운 항으로 복사하여 다항식 C에 추가한다. 그리고 q만 다음 항으로 이동한다.

3. p.expon > q.expon
   p가 가리키는 항을 새로운 항으로 복사하여 다항식 C에 추가한다. 그리고 p만 다음 항으로 이동한다.

위 과정을 p, q 둘 중 하나가 NULL이 될 때까지 되풀이하고 p, q 중 하나가 NULL 이 되면 아직 남아 있는 항들을 전부 C로 가져온다.

이중 연결 리스트에서 언급했던 헤드 노드를 활용하여 효율적인 계산을 위해 헤드 노드에 head 와 tail 포인터를 표현해준다. 추가로 연결 리스트에 들어 있는 항목들의 개수를 넣어주기도 한다. 헤드 노드가 있으면 맨 끝에 노드를 추가하는 경우 단순 연결 리스트의 경우 매번 추가할 때마다 처음부터 포인터를 따라서 끝까지 순회해야 하지만 마지막 노드를 가리키는 포인터가 있으면 맨 끝에 노드를 추가할 때 효율적으로 추가할 수 있다.
하지만 이를 위해 항상 연결 리스트를 생성한 다음 초기화를 해주어야 하는 단점이 있다.

```
// 헤더 노드
typedef struct ListHeader {
  int length;
  ListNode *head;
  ListNode *tail;
} ListHeader;
```

```
void init(ListHeader *plist) {
  plist->length=0;
  plist->head = plist->tail = NULL;
}
```

```
void insert_node_last(ListNode *plist, int coef, int expon) {
  ListNode *temp = (ListNode *)malloc(sizeof(ListNode));
  if (temp == NULL) error("메모리 할당 에러");

  temp->coef=coef;
  temp->expon=expon;
  temp->link=NULL;

  if (plist->tail == NULL) {
    plist->head = plist->tail = temp;
  } else {
    plist->tail->link = temp;
    plist->tail = temp;
  }

  plist->length++;
}
```

```
void poly_add(ListHeader *plist1, ListHeader *plist2, ListHeader *plist3) {
  ListNode *a = plist1->head;
  ListNode *b = plist2->head;
  int sum;

  while (a != NULL && b != NULL) {
    if (a->expon == b->expon) {
      sum = a->coef + b->coef;
      if (sum != 0) insert_node_last(plist3, sum, a->expon);
      a = a->link;
      b = b->link;
    } else if (a->expon > b->expon) {
      insert_node_last(plist3, a->coef, a->expon);
      a = a->link;
    } else {
      insert_node_last(plist3, b->coef, b->expon);
      b = b->link;
    }
  }

  if (a!=NULL) {
    for (; a!= NULL; a=a->link) insert_node_last(plist3, a->coef, a->expon);
  }

  if (b!=NULL) {
    for (; b!=NULL; b=b->link) insert_node_last(plist3, b->coef, b->expon);
  }
}
```

```
void poly_print(ListNode *plist) {
  ListNode *p = plist->head;
  for (; p; p=p->link) {
    printf("%d %d\n", p->coef, p->expon);
  }
}
```

### 연결 리스트로 구현된 리스트

```
typedef struct {
  ListNode *head;
  int length;
} LinkedListType;

int is_empty(LinkedListType *list) {
  if (list->head == NULL) return 1;
  else return 0;
}

int get_length(LinkedListType *list) {
  return list->length;
}
```

```
// pos 로 위치를 받아서 그 위치에 해당하는 노드의 주소를 반환하는 함수
ListNode *get_node_at(LinkedListType *list, int pos) {
  int i;
  ListNode *tmp_node = list->head;
  if (pos < 0) return NULL;
  for (i=0; i<pos; i++) {
    tmp_node = tmp_node->link;
  }
  return tmp_node;
}
```

```
void add(LinkedListType *list, int position, element data) {
  ListNode *p;
  if ((position >= 0) && (position <= list->length)) {
    ListNode *node = (ListNode*)malloc(sizeof(ListNode));
    if (node == NULL) error("메모리 할당 에러");

    node->data = data;
    // 주소값이 이전 값을 가리키고 있으므로 현재 주소값을 가리키기 위해 -1 해줌
    p = get_node_at(list, position-1);
    insert_node(&(list->head), p, node);
    list->length++;
  }
}

void insert_node(ListNode **phead, ListNode *p, ListNode *new_node) {
  // 공백 리스트
  if (*phead == NULL) {
    new_node->link = NULL;
    *phead = new_node;
  }
  // p가 NULL 이면 첫 번째 노드로 삽입
  else if (p == NULL) {
    new_node->link = *phead;
    *phead = new_node;
  }
  // p 다음 삽입
  else {
    new_node->link = p->link;
    p->link = new_node;
  }
}

void add_last(LinkedListType *list, element data) {
  add(list, get_length(list), data);
}

void add_first(LinkedListType *list, element data) {
  add(list, 0, data);
}
```

```
// pos 위치의 자료를 삭제
void delete(LinkedListType *list, int pos) {
  if (!is_empty(list) && (pos >= 0 ) && (pos < list->length)) {
    ListNode *p = get_node_at(list, pos-1); // 노드 삭제 시 노드의 선행 노드의 주소가 필요함
    ListNode *removed = get_node_at(list, pos);
    remove_node(&(list->head), p, removed);
    list->length--;
  }
}
```

```
// pos에 해당하는 데이터를 반환하는 연산
element get_entry(LinkedListType *list, int pos) {
  ListNode *p;
  if (pos >= list->length) error("위치 오류");
  p = get_node_at(list, pos);
  return p->data;
}

// 모든 노드 삭제
void clear(LinkedListType *list) {
  int i;
  for (i=0; i<list->length;i++)
    delete(list, t);
}
```

```
void display(LinkedListType *list) {
  int i;
  ListNode *node = list->head;
  for (i=0; i<list->length; i++) {
    printf("%d ", node->data);
    node = node->link;
  }
}
```

```
// 리스트 탐색 함수
int is_in_list(LinkedListType *list, element item) {
  ListNode *p;
  p = list->head; // 헤드 포인터를 직접 사용하여 변경하면 상실되므로 복사하여 사용해야 함!!
  while (p != NULL) {
    if (p->data == item) break;
    p = p->link;
  }

  if (p== NULL) return False;
  else return True;
}
```

#### 연결 리스트로 구현된 리스트 사용 시 주의할 점

리스트의 항목들을 순차적으로 방문하면서 어떤 작업을 해야 되는 경우 리스트 ADT가 제공하는 연산보다 연결 리스트가 제공하는 포인터를 이용한 연산이 훨씬 효율적이다. 그러므로 리스트 ADT보다는 연결 리스트가 제공하는 함수 또는 포인터를 이용하여 작업하는 것이 좋다. 물론 ADT가 제공하는 장점들은 포기해야 한다.

객체 지향 언어에선 이런 경우를 위해 Iterator 라는 개념으로 순차적으로 객체를 효율적으로 방문하면서 작업할 수 있도록 연산을 제공한다.

```
// 리스트 ADT (비효율적)
void visit(LinkedListType *list) {
  int i, data;
  int length = get_length(list);
  for (i=0; i<length; i++) {
    data = get_entry(list, pos);
    replace(list, pos, data+1);
  }
}

// 포인터 사용 (효율적)
void visit(LinkedListType *list) {
  ListNode *p = list->head;
  while(p!=NULL) {
    p->data++;
    p = p->link;
  }
}
```

### 선형 리스트 응용 - 텍스트 에디터

연결 리스트로 구현된 선형 리스트를 활용하면 라인 에디터라고 불리는 간단한 텍스트 에디터를 만들 수 있다. 라인 단위로 입력이나 삭제를 할 수 있고 고정된 수의 명령어들을 받아서 동작하며 커서를 사용하지 않는다.
buffer 라고 불리는 연결 리스트를 사용하여 사용자가 입력하는 텍스트를 저장하고 라인의 번호와 라인의 내용을 입력받아 지정된 위치에 삽입한다. 삭제또한 번호를 입력받고 지정된 라인을 buffer 연결 리스트에서 삭제한다. 라인의 총 개수가 어떻게 될지 미리 알 수 없기 때문에 연결 리스트를 사용하는 것이 효율적이다.

```
typedef struct {
  char a[MAX_CHAR_PER_LINE];
} element;

typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

typedef struct {
  ListNode *head;
  int length;
} LinkedListType;
```

```
void read_file(LinkedListType *buffer) {
  char fname[MAX_NAME];
  FILE *fd;
  element p;

  if (!is_empty(buffer)) {
    clear(buffer);
  }
  init(buffer);

  printf("파일 이름: ");
  scanf("%s", fname);
  if ((fd = fopen(fname, "r") == NULL)) {
    return;
  }

  while (fgets(p.a, MAX_CHAR_PER_LINE, fd)) {
    add_last(buffer, p);
  }
  fclose(fd);
  display(buffer);
}
```

```
void write_file(LinkedListType *buffer) {
  FILE *fd;
  char fname[MAX_NAME];
  element p;
  ini i;

  printf("파일 이름:" );
  scanf("%s", fname);
  if ((fd = fopen(fname, "w") == NULL)) {
    printf("파일을 열 수 없습니다\n");
    return;
  }

  for (i=0; i<get_length(buffer); i++) {
    p = get_entry(buffer, i);
    fputs(p.a, fd);
  }
  fclose(fd);
  display(buffer);
}
```

```
void delete_line(LinkedListType *buffer) {
  int position;

  if (is_empty(buffer)) printf("지울 라인이 없습니다.");
  else {
    printf("지우고 싶은 라인번호를 입력하세요");
    scanf("%d", &position);
    delete(buffer, position);
  }
  display(buffer);
}

void insert_line(LinkedListType *buffer) {
  int position;
  char line[MAX_CHAR_PER_LINE];
  element p;

  printf("입력행 번호를 입력하세요");
  scanf("%d", &position);

  printf("내용을 입력하세요: ");
  fflush(stdin);
  fgets(line, MAX_CHAR_PER_LINE, stdin);
  strcpy(p.a, line);
  add(buffer, position, p);
  display(buffer);
}
```

```
void do_command(LinkedListType *buffer, char command) {
  switch(command) {
    case 'd':
      delete_line(buffer); break;
    case 'i':
      insert_line(buffer); break;
    case 'r':
      read_file(buffer); break;
    case 'w':
      write_file(buffer); break;
    case 'q':
      break;
  }
}
```

---

# 스택

LIFO, FILO 형태로 입출력이 일어나는 자료구조
제일 먼저 입력된 데이터가 맨 아래에 쌓이고 가장 최근에 입력된 데이터가 가장 위에 쌓이는 구조를 나타낸다.
즉 스택의 입출력은 맨 위에서만 일어나고 스택의 중간에서는 데이터를 삭제할 수 없다.

- stack top
- stack bottom
- element

```
Stack ADT
객체 : n 개의 element 타입의 요소들의 순서 있는 모임
연산
- create()
- is_empty(s)
- is_full(s)
- push(s, e)
- pop(s)
- peek(s)
```

스택의 기본 연산에는 삽입 연산인 push 와 삭제 연산인 pop 이 있다. peek과 pop의 차이점은, peek연산은 요소를 스택에서 삭제하지 않고 보기만 하는 연산이고 pop연산은 요소를 스택에서 완전히 삭제하면서 요소를 가져온다,

스택의 경우 자료의 출력 순서가 입력 순서의 역순으로 이루어져야 할 때 사용된다. 에디터의 되돌리기(undo), 함수 호출에서 함수는 실행이 끝나면 가장 최근에 자신을 호출한 함수로 되돌아가야 하는데, 이때 복귀 주소를 기억하는데 스택을 사용한다.

물론 함수의 호출에서 사용되는 스택은 시스템 스택이므로 사용자가 접근할 순 없다. 시스템 스택에서는 함수가 호출될 때마다 활성화 레코드가 만들어지고 여기에 함수로부터 복귀 후에 실행될 명령어의 주소인 프로그램 카운터 값이 기록된다. 즉 활성화 레코드에는 프로그램 카운터뿐만 아니라 함수 호출 시 매개변수와 함수안에서 선언된 지역 변수들이 함께 저장된다.

## 배열로 구현한 스택

- top 변수: 가장 최근에 입력되었던 자료
- stack[MAX_STACK_SIZE]
- stack[0]: 가장 먼저 들어온 요소
- stack[top]: 가장 최근에 들어온 요소

배열에서 0은 값이 있다는 것을 의미하므로 top변수는 스택에 아무런 데이터가 없을 때 -1을 갖게 설정한다. 그리고 top 변수가 MAX_STACK_SIZE-1 을 가리키면 포화 상태를 가리킨다.

```
int is_empty() {
  return (top == -1);
}

int is_full() {
  return top == MAX_STACK_SIZE-1
};
```

아래 방법은 top 변수를 전역 변수로 구현하여 매개변수로 전달할 필요가 없다.

```
void push(element item) {
  if (is_full()) {
    fprintf(stderr, "스택 포화"); return;
  }
  else {
    stack[++top] = item;
  }
}
```

```
element pop() {
  if (is_empty()) {
    fprintf("스택 공백 에러");
    exit(1);
  } else {
    return stack[top--];
  }
}

element peek() {
  if (is_empty()) {
    fprintf("스택 공백 에러");
    exit(1);
  } else {
    return stack[top];
  }
}
```

전역변수로 구현한 스택은 하나 이상의 스택을 사용할 때 복잡하게 만들어서 오류가 발생할 가능성을 높인다.

스택에 저장되어야 하는 값이 복잡한 구조를 갖는 경우 구조체로 요소를 만들어주면 된다.

```
typedef struct {
  int student_no;
  char name[MAX_STRING];
  char address[MAX_STRING];
} element;
element stack[MAX_STACK_SIZE];
int top = -1;

int is_empty(){
  return (top == -1);
}
int is_full() {
  return (top == MAX_STACK_SIZE-1);
}
```

```
void push(element item) {
  if (is_full()) {
    fprintf("스택 포화 에러");
    return;
  } else {
    return stack[++top] = item;
  }
}
```

```
element pop() {
  if (is_empty()) {
    fprintf("스택 공백 에러");
    exit(1);
  } else {
    return stack[top--];
  }
}
element peek() {
  if (is_empty()) {
    fprintf("스택 공백 에러");
    exit(1);
  } else {
    return stack[top];
  }
}
```

stack 배열과 top이 전역 변수로 선언되기 때문에 전체 프로그램에서 여러 개의 스택을 사용하기 어렵다는 단점이 있다.
top과 stack 배열을 하나의 구조체로 결합시켜 구조체의 포인터를 함수의 매개변수로 전달하는 방식으로 사용하여 구조체포인터->top 형식으로 변경해주는 것이다.
구조체로 만들어주면 여러 개의 스택을 만드는 것이 가능해진다.
다만 이 스택 포인터는 초기화를 위해 1차원 배열을 0으로 채울 필요는 없고 top의 값만 -1로 하여 비어있는 것으로 간주한다.

```
typedef struct {
  element stack[MAX_STACK_SIZE];
  int top;
} StackType;

void init(StackType *s) {
  s->top = -1;
}
```

```
int is_empty(StackType *s) {
  return (s->top == -1);
}

int is_full(StackType *s) {
  return (s->top == MAX_STACK_SIZE-1);
}
```

```
void push(StackType *s, element item) {
  if (is_full(s)) return;
  else s->stack[++s->top] = item;
}
```

```
element pop(StackType *s) {
  if (is_empty(s)) return;
  else return s->stack[(s->top)--];
}

element peek(StackType *s) {
  if (is_empty(s)) return;
  else return s->stack[s->top];
}
```

스택을 구조체로 표현하면서 구조체의 포인터를 각 함수에 전달하고 구조체의 포인터를 이용하여 스택을 조작한다.
C에선 함수의 매개 변수 전달 방식이 값 전달 방식이기 때문에 구조체의 원본이 전달되는 것이 아닌 구조체의 복사본이 함수에 전달되므로 함수 안에서 복사본을 수정하더라도 원본에는 영향을 줄 수 없기 때문에 가능하다.
하지만 원본에 대한 포인터를 전달하면 원본을 변경할 수 있다.

## 연결 리스트로 구현한 스택

연결된 스택이라고 부르며 외부에서 보기엔 외부 인터페이스가 완전히 동일하여 배열으로 구현한 것이나 연결 리스트로 구현한 것인가 차이는 없다.
차이점이라고 하면 스택 내부의 구현으로 연결 리스트를 이용하면 크기가 제한되지 않아 동적 메모리 할당만 가능하다면 스택에 새로운 요소를 삽입할 수 있는 점과 연결 리스트의 경우 동적 메모리 할당이나 해제가 필요하므로 삽입이나 삭제 시간이 좀더 걸린다는 점이 다르다.

```
typedef int element;

typedef struct StackNode {
  element item;
  struct StackNode *link;
} StackNode;

typedef struct {
  StackNode *top;
} LinkedStackType;
```

연결된 스택은 연결 리스트로 구현하므로 link필드를 포함한 구조체로 정의한다. top 은 더이상 정수가 아니고 노드를 가리키는 포인터로 선언되며 연결된 스택에 관련된 데이터는 top 뿐이지만
LinkedStackType 구조체로 정의한다.

```
void init(LinkedStackType *s) {
  s->top = NULL;
}

int is_empty(LinkedStackType *s) {
  return (s->top == NULL);
}

int is_full(LinkedStackType *s) // 삭제
```

연결 리스트로 구현된 스택의 공백 상태는 top 포인터가 NULL 인 경우로 알 수 있지만 포화 상태는 동적 메모리 할당이 된다면 노드를 생성해줄 수 있기 때문에 없어지게 된다.

```
void push (LinkedStackType *s, element item) {
  StackNode *temp = (StackNode *)malloc(sizeof(StackNode));
  if (temp == NULL) return;
  else {
    temp->item = item;
    temp->link = s->top;
    s->top = temp;
  }
}
```

```
element pop(LinkedStackType *s) {
  if (is_empty(s)) return;
  else {
    StackNode *temp = s->top;
    element item = temp->item;
    s->top = s->top->link;
    free(temp);
    return item;
  }
}

element peek(LinkedStackType *s) {
  if (is_empty(s)) return;
  else return s->top->item;
}
```

## 괄호 검사

괄호는 여러가지 타입의 괄호들이 같은 타입으로 쌍으로 존재하여야 한다.
조건1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다
조건2. 같은 타입의 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
조건3. 서로 다른 타입의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로를 교차하면 안된다.

스택을 사용하여 괄호 사용의 오류를 검사할 수 있다. 가까운 거리에 있는 괄호들끼리 서로 쌍을 이루어야 되므로 왼쪽 괄호를 만나면 스택에 넣었다가 오른쪽 괄호가 나오면 스택에서 최근 왼쪽 괄호를 꺼내어 타입을 맞춰보면 오류 검사가 가능하다.

1.문자열이 있는 괄호를 차례대로 조사 2.왼쪽 괄호를 만나면 스택에 삽입 3.오른쪽 괄호를 만나면 스택의 맨 위에서 괄호를 꺼내어 짝이 맞는지 검사

- 스택이 비어있으면 -> 조건1, 조건2 위반
- 괄호의 짝이 맞지 않으면 -> 조건3 위반
- 마지막 조사 후 스택에 괄호가 남아있으면 -> 조건1 위반

```
int check_matching(char *in) {
  StackType s;
  char ch, open_ch;
  int i, n = strlen(in);
  init(&s);

  for (i =0; i < n; i++) {
    ch =in[i];
    switch(ch) {
      case '(': case '[': case '{':
        push(&s, ch);
      case ')': case ']': case '}':
        if (is_empty(&s)) return False;
        else {
          open_ch = pop(&s);
          if ((open_ch == '(' && ch != ')') ||
              (open_ch == '[' && ch != ']') ||
              (open_ch == '{' && ch != '}')) {
                return False;
              }
              break;
        }
    }
  }

  if (!is_empty(&s)) return False;
  return True;
}
```

## 수식 계산

- 전위 수식
- 중위 수식
- 후위 수식

인간은 주로 중위 표기법을 사용하나 컴파일러는 주로 후위 표기법을 사용한다. 후위 표기법은 괄호가 없어도 우선 순위가 반영되어 있다.
즉 프로그래머가 수식을 중위 표기법으로 작성하면 컴파일러는 이것을 후위 표기법으로 변환한 다음 스택을 이용하여 계산한다. 이는 괄호를 고려할 필요 없이 수식을 읽으면서 바로 계산을 해도 되기 때문이다.

후위 표기식에서 어떻게 스택을 이용하여 계산할 수 있는가에선 후위 표기식을 계산하려면

1. 먼저 수식을 왼쪽에서 오른쪽으로 스캔한 다음,
2. 피연산자를 만나면 스택에 저장하고
3. 연산자면 필요한 수만큼 피연산자를 스택에서 꺼내서 연산 실행
4. 연산의 결과는 다시 스택에 저장

이때 연산을 하려고 하다가 스택에 원하는 만큼의 피연산자가 없으면 오류가 발생할 것이다.

```
// 후위 표기법
int eval(char exp[]) {
  int op1, op2, value, i=0;
  int len = strlen(exp);
  char ch;
  StackType s;
  init($s);

  for (i=0; i<len; i++) {
    ch = exp[i];
    // 피연산자 일때
    if(ch != '+' && ch != '-' && ch != '*' && ch != '/') {
      value = ch - '0';
      push(&s, value);
    } else {
      op2 = pop(&s);
      op1 = pop(&s);
      switch(ch) {
        case '+': push(&s, op1+op2); break;
        case '-': push(&s, op1-op2); break;
        case '*': push(&s, op1*op2); break;
        case '/': push(&s, op1/op2); break;
      }
    }
  }
}
```

중위표기법과 후위 표기법은 피연산자의 순서가 동일하다는 공통점이 있지만 연산자들의 순서가 달라진다는 차이점이 있다. 연산자들의 순서는 우선순위에 따라 결정된다.
연산자들의 우선순위에 의해 스택에 *가 들어 있는데 +를 스택에 넣으면 안된다. 나중에 +가 먼저 출력되어 *보다 먼저 계산되면 안되기 때문이다.
즉 스택에 존재하는 연산자가 현재 처리 중인 연산자보다 우선순위가 높으면 일단 스택에 있는 연산자들을 먼저 출력한 다음 처리 중인 연산자를 스택에 넣어줘야 한다.
우선순위가 같은 경우 또한 일단 스택 상단의 요소를 꺼내어 출력해야 한다.

괄호의 경우 왼쪽 괄호는 무조건 스택에 삽입한다. 즉 왼쪽 괄호를 우선순위가 낮은 연산자로 취급하여 다음에 만나는 연산자들을 스택에 담아주고, 오른쪽 괄호를 만나게 되면
왼쪽 괄호가 삭제될 때까지 왼쪽 괄호 위에 쌓여 있는 모든 연산자들을 출력하게 된다.

```
int prec(char op) {
  switch(op) {
    chase '(': case: ')': return 0;
    chase '+': case: '-': return 1;
    chase '*': case: '/': return 2;
  }
  return -2;
}

void infix_to_postfix(char exp[]) {
  int i = 0;
  char ch, top_op;
  int len=strlen(exp);
  StackType s;

  init(&s);
  for (i=0; 0<len; i++) {
    ch = exp[i];
    switch(ch) {
      case '+': case '-': case '*': case '/':
        while (!is_empty(&s) && prec(ch) <= prec(peek(&s))) {
          // 스택에 있는 연산자의 우선순위가 더 크거나 같으면 출력
          pop(&s);
        }
        push(&s, ch); break;
      case '(':
        push(&s, ch);
        break;
      case ')':
        top_op = pop(&s);
        while (top_op != '(') {
          top_op = pop(&s);
        }
        break;
      default:
        // 피연산자
        printf("%c", ch); break;
    }
  }

  while(!is_empty(&s)) printf("%c", pop(&s));
}
```

## 미로 탐색 문제

- 미로는 서로 연결된 여러 개의 작은 방 또는 칸으로 구성
- 하나의 경로를 선택하여 한 번 시도해보고 안되면 다른 경로를 시도
- 다른 경로를 선택할 때 가능한 경로들이 어딘가에 저장되어 있어야 한다
- 현재 위치에서 가능한 경로 중 가장 가까운 경로를 저장 => 스택
  즉 현재 위치에서 갈 수 있는 칸들의 좌표를 스택에 기억했다가 막다른 길을 발견하면 가장 가깝고 아직 가보지 않은 칸으로 다시 돌아가서 새로운 경로를 찾는다.
- 방문한 곳은 표시

### 미로 구성

2차원 문자배열 maze[][]를 이용하여 미로를 표현
배열의 값이 0이면 갈 수 있는 길이고 1이면 지나갈 수 없는 벽을 의미
출구는 x, 현재 위치는 m
위치를 (행, 열) 좌표로 표시하여 스택에 저장되는 데이터도 (행, 열)로 구성할 수 있게 구조체로 구현
방문이 끝난 위치는 maze[][] 배열 값을 .으로 바꾸고 다른 위치들과 구별
스택이 비어 있음에도 출구를 못 찾으면 미로 탐색이 실패했음을 출력하고 프로그램을 끝냄
동일 좌표값이 중복해서 스택에 저장되어도 문제 없음

```
typedef struct = {
  short r;
  short c;
} element;

element here = {1, 0}, entry = {1, 0};

char maze[MAZE_SIZE][MAZE_SIZE] = {
  {'1','1','1','1','1','1'},
  {'e','0','1','Q','Q','1'},
  {'1','0','0','0','1','1'},
  {'1','0','1','0','1','1'},
  {'1','0','1','0','0','x'},
  {'1','1','1','1','1','1'},
}
```

```
// 위치를 스택에 삽입
void push_loc(StackType *s, int r, int c) {
  if (r<0 || c<0) return;
  if (maze[r][c] != '1' && maze[r][c] != '.') {
    // 벽이 아니고 방문되지 않았으면
    elment tmp;
    tmp.r = r;
    tmp.c = c;
    push(s, tmp);
  }
}
```

```
void main() {
  int r, c;
  StackType s;

  init(&s);
  here = entry;
  while (maze[here.r][here.c] != 'x') {
    r = here.r;
    c = here.c;
    maze[r][c] = '.';
    push_loc(&s, r-1, c);
    push_loc(&s, r+1, c);
    push_loc(&s, r, c-1);
    push_loc(&s, r, c+1);
    if (is_empty(&s)) { printf("실패"); return; }
    else {
      here = pop(&s);
    }
  }
}
```

---

# 정렬

여러 개의 데이터가 구성된 리스트가 주어졌을 때 이 데이터들을 값의 크기 순서대로 재배치하는 것
데이터의 개수가 많을 때는 데이터에 다른 연산을 취하기 전 데이터를 정렬시켜 연산 속도를 높일 수 있다.

정렬을 수행하는 시점에 데이터가 어디에 저장되어 있는지 여부에 따라 구분된다.

1. 내부 정렬
   정렬할 데이터 전체를 주기억장치에 저장한 후 정렬을 수행하는 방식
2. 외부 정렬
   모든 데이터를 보조기억장치에 저장해 두고 그중 일부 데이터만 반복적으로 주기억장치로 옮겨와서 정렬을 수행하는 방식

## 안정적 정렬 알고리즘

동일한 값을 가지는 데이터가 여러 개 있을 때 정렬 전 상대적 위치가 정렬 후에도 그대로 유지되는 것이 보장될 때 (반대는 불안정적 정렬 알고리즘)

## 제자리(in place)

즉 정렬을 수행할 때 정렬 대상이 되는 입력 데이터가 저장되는 공간 이외에 얼마나 많은 메모리가 필요한지 나타내기 위해 제자리(in place) 개념이 사용된다. 그래서 입력 배열 외에 별도로 필요한 저장 공간이 상수 개를 넘지 않는 정렬 알고리즘

## 비교 기반의 정렬 알고리즘

정렬 과정에서 두 값 전체를 직접적으로 비교하여 어떤 값이 큰지, 작은지를 결정하는 방식으로 정렬을 수행하는 것
-> 값의 비교 횟수를 알고리즘의 수행시간으로 간주
ex. 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬은 O(n^2) 의 성능을 퀵 정렬, 합병 정렬, 힙 정렬은 O(nlogn)의 비교를 통해 정렬을 수행함. 계수 정렬, 기수 정렬, 버킷 정렬은 데이터 분포에 기반은 정보를 바탕으로 정렬을 수행하므로 자료의 이동 횟수를 수행시간으로 간주하여 O(n) 성능을 가진다.

## 기초적인 정렬 알고리즘 O(n^2)

### 선택 정렬

주어진 배열에서 가장 작은 값, 두 번째로 작은 값,.. 등 순서대로 선택해서 나열하는 방식

입력 배열 전체 A[0..n-1]에 대해서 최솟값을 찾아서 배열 A[0]에 위치시키면 A[0]은 정렬된 부분이고 A[1..n-1]은 미정렬 부분이 됨. 아직 정렬되지 않은 부분 A[1..n-1]에서 다시 최솟값을 찾아서 미정렬 부분의 첫 번째 데이터 A[1]과 최솟값의 위치를 교환하는 방식을 반복한다. 마지막에선 미정렬 부분 [n-2..n-1]의 2개의 데이터 중 최솟값을 찾아서 A[n-2]와 위치를 교환하여 정렬이 완료된다.

```
SelectionSort(A[], n)
입력 A[0..n-1]
n: 입력 크기(데이터 수)
출력: A[0..n-1] 정렬된 배열
{
for (i=0;i<n-1;i++) { -> n-1번 반복
min = i;
for (j=i+1;j<n;j++)
if (A[min] > A[j])
min = j;
A[i]와 A[min]의 자리바꿈;
}
return (A);
}
```

단계마다 미정렬 부분에서 최솟값을 찾고 첫 번째 데이터와의 위치를 교환하는 과정을 수행

- 선택 정렬은 비교적 간단하며 입력 크기 n이 작으면 효율적
- O(n^2)
  - 이중 루프로 구성됨
- 입력 데이터의 순서에 민감하지 않음
  - k번째 단계에서 미정렬된 부분은 항상 n-k번의 비교를 수행하여 최솟값을 찾을 때 이 과정에서 입력 데이터가 오름차순/내림차순으로 정렬되어 있거나 임의의 순서로 나열되어 있는지와는 무관하게 수행됨
  - 즉 입력 데이터가 어떤 순서 상태를 가지느냐에 상관없이 항상 일정한 수행시간을 가짐
- 제자리 정렬 알고리즘
  - 배열 이외에 별도로 필요한 저장 공간은 루프의 제어 변수 i, j와 최솟값의 위치를 나타내는 min, 위치 교환 과정에서 필요한 하나의 변수가 추가로 필요하다. 이는 별도의 저장 공간이 상수 개를 넘지 않으므로 선택 정렬은 제자리 정렬 알고리즘이라 할 수 있다.
- 안정적 정렬 알고리즘은 아님
  - 동일한 값을 갖는 데이터에 대한 정렬 전후의 상대적인 위치가 유지되지 못하므로 알고리즘이 안정적이지 않음을 알 수 있음

### 버블 정렬

인접한 두 데이터를 차례대로 비교하여 왼쪽 데이터가 더 큰 경우 오른쪽 데이터와 자리를 바꾸는 과정을 반복해서 정렬을 수행하는 방식
이러한 인접한 두 데이터의 비교, 교환 과정을 오른쪽으로 이동하면서 n-1번 반복해서 모든 데이터에 대한 처리가 끝나면 전체 데이터 중에서 가장 큰 데이터가 오른쪽 끝에 위치하게 된다.

```
BubbleSort(A[], n)
입력 A[0..n-1] 입력 배열
n 입력 크기
출력 A[0..n-1] 정렬된 배열
// 왼쪽->오른쪽 진행
{
for (i=0;i<n-1;i++) -> n-1번 반복
for (j=0;j<n-1;j++) -> 왼쪽->오른쪽 진행
if (A[j] > A[j+1])
A[j]와 A[j+1]의 자리바꿈;
return (A);
}

// 오른쪽 -> 왼쪽 진행
{
for (i=0;i<n-1;i++) -> n-1번 반복
for (j=n-1;j>0;j--) -> 오른쪽->왼쪽 진행
if (A[j-1] > A[j])
A[j]와 A[j+1]의 자리바꿈;
return (A);
}
```

ex. 버블 정렬 예시
A[] = {30, 20, 40, 35, 5, 10, 45, 50, 25, 15}

1. [30,20], [[[40, 35], 5], 10], 45, [50, [25], 15]
2. 20, 30, [35, [5], 10], 40, [[45, 25], 15], 50
3. 20, [30, [5], 10], 35, [40, [25], 15], 45, 50
4. [20, [5], 10], 30, [35, [15], 25], 40, 45, 50
5. 5, 10, 20, [30, [15], 25], 35, 40, 45, 50
6. 5, 10, [20, 15], 25, 30, 35, 40, 45, 50
7. 5, 10, 15, 20, 25, 30, 35, 40, 45, 50

- O(n^2)
  - 이중 루프
- 안정적인 정렬 알고리즘
  - 인접한 두 데이터가 정렬되지 않은 경우에만 자리바꿈이 발생
- 제자리 정렬 알고리즘
  - 상수 개의 저장 공간이 요구됨
- 정렬 과정에서 비교 횟수를 줄일 여지가 있음
  - 데이터가 이미 정렬된 상태라면 인접한 두 데이터를 비교하더라도 자리바꿈이 발생하지 않으므로 변수를 추가하여 자리바꿈이 일어나는지 여부를 확인하고 일어나지 않으면 알고리즘을 종료하도록 해주면 비교 횟수를 줄일 수 있음
- 입력 데이터의 상태에 따라 성능이 달라짐
  - 개선된 버블 정렬
- 선택 정렬에 비해 데이터 교환이 많이 발생
  - 버블 정렬은 올바른 자리를 찾기 위해 그 사이에 있는 모든 데이터와 자리바꿈을 수행하지만 선택 정렬은 최솟값으로 선택된 데이터와 자리바꿈이 한번만으로 이루어진다. 즉 버블 정렬이 선택 정렬보다 데이터 교환이 많이 일어나게 된다.

```
개선된 버블 정렬
Advanced_BubleSort(A[], n)
입력 A[0..n-1] 입력 배열
n 입력 크기
출력 A[0..n-1] 정렬된 배열
{
for (i=0;i<n-1;i++) {
Sorted = TRUE;
for (j=0; j<(n-1)-i; j++) {
if (A[j] > A[j+1]) {
A[j]와 A[j+1] 자리바꿈;
Sorted = FALSE; // 자리바꿈이 생겼다는 것은 정렬 되지 않았다는 의미이므로 다음 단계의 처리를 진행
}
}
if (Sorted == TRUE) break; // 자리바꿈이 생기지 않았다는 의미는 이미 정렬되었다는 것이므로 이후의 단계는 생략 가능
}
return (A);
}
```

개선된 버블 정렬 알고리즘에 따르면 A[] = {10, 20, 30, 40, 50} 의 입력 배열을 받았을 때 안쪽 For문에 의해 비교가 4번 수행했음에도 Sorted 가 True 이므로 자리바꿈이 생기지 않았기 때문에 break 를 만나 알고리즘을 종료하게 된다. 그래서 n개의 크기에서 n-1번 비교를 수행하기 때문에 O(n) 의 수행시간이 될 수 있다.
이처럼 버블 정렬은 입력 데이터의 순서에 따라 성능이 달라진다. 최선의 수행시간 O(n) 부터 최악의 수행시간 O(n^2)를 보인다.

### 삽입 정렬

주어진 데이터를 하나씩 뽑은 뒤 나열된 데이터가 항상 정렬된 형태를 유지하도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식

입력 배열을 정렬 부분과 미정렬 부분으로 구분하여 미정렬 부분의 첫 번째 데이터를 뽑은 뒤 정렬 부분에서 뽑은 데이터가 위치할 제자리를 찾아서 삽입하는 처리 단계를 반복 수행
일반적으로 삽입 정렬의 k번째 단계가 시작될 때는 배열의 앞부분의 K개의 데이터 A[0..k-1] 는 이미 정렬된 부분이고 A[k..n-1]은 미정렬 부분이 된다. 그래서 첫 단계에선 주어진 배열의 첫 번째 데이터 A[0]을 정렬 부분으로 취급하고 정렬을 시작하게 된다.

각 단계에서 핵심적인 처리는 미정렬 부분에서 뽑은 데이터 A[k]의 바른 위치를 찾는 것으로 A[k]보다 큰 값을 갖는 데이터는 오른쪽으로 한 칸 이동시켜서 해당 위치를 빈 공간으로 만들고 A[k]보다 작으면 해당 데이터 뒤의 빈 공간에 A[k]를 삽입해준다.

```
InsertSort(A[], n)
입력 A[0..n-1] 입력 배열
n 입력 크기
출력 A[0..n-1] 정렬된 배열
{
for (i=1;i<n;i++) { -> n-1 반복
val = A[i]; -> 미정렬된 부분의 첫 번째 데이터 선택
for (j=1;j>0 && A[j-1]>val;j--) { -> 정렬 부분에서 삽입할 위치 찾기
A[j] = A[j-1] -> 정렬 부분의 A[j-1]이 크면 값을 뒤로 이동
}
A[j] = val; -> 찾은 위치에 선택된 데이터 삽입
}
return (A);
}
```

ex. 삽입 정렬 예시
A[] = {30, 20, 40, 35, 5, 10, 45, 40, 25, 15}

1. 30 | 20, 40, 35, 5, 10, 45, 50, 25, 15 -> 비교 1회
2. 20, 30 | 40, 35, 5, 10, 45, 50, 25, 15 -> 비교 1회
3. 20, 30, 40 | 35, 5, 10, 45, 50, 25, 15 -> 비교 2회
   ...
4. 5, 10, 20, 25, 30, 35, 40, 45, 50 | 15 -> 비교 7회
5. 5, 10, 15, 20, 25, 30, 35, 40, 45, 50

- 최악의 수행시간은 O(n^2)
  - 각 단계에서 삽입될 제자리를 찾을 때 최악의 경우인 삽입 데이터가 정렬 부분의 모든 데이터보다 작은 값이라면 정렬 부분의 오른쪽 끝에서부터 한 번에 하나씩 비교를 통해 왼쪽으로 한 칸씩 이동해서 제자리를 찾아가고 정렬 부분의 데이터가 많을수록 비교와 이동 횟수가 증가하게 됨
- 안정적인 정렬 알고리즘
  - 두 데이터가 정렬되지 않은 경우에만 위치 교환이 발생
- 제자리 정렬 알고리즘
  - 추가적인 저장 공간이 상수 개
- 입력 데이터의 원래 순서에 민감
  - 입력 데이터의 원래 순서에 따라 비교가 진행되므로 평균 성능 측면에선 범용성이 떨어지나 입력 데이터가 정렬된 상태로 주어지면 어떤 정렬 알고리즘보다 효율적일 수 있음

### 셀 정렬

삽입 정렬의 단점을 보완하기 위한 정렬 알고리즘으로 멀리 떨어진 데이터와의 비교, 교환으로 한 번에 이동할 수 있는 거리를 늘려서 처리 속도를 향상하기 위한 것
처음에는 멀리 떨어진 두 데이터를 비교하여 필요하면 위치를 교환하고 점차 가까운 위치의 데이터를 비교, 교환한 뒤 맨 마지막에는 인접한 두 데이터를 비교, 교환하는 방식의 정렬 알고리즘

ex. 셸 정렬 예시
A[] = {30, 50, 10, 40, 75, 20, 45, 55, 25, 35, 65, 80, 15, 60, 5, 70}
셸 정렬은 입력 배열을 몇 개의 부분 배열로 나누는데, 4개의 부분배열로 나눈다고 가정했을 때
첫번째 부분배열: 30, 75, 25, 15
두번째 부분배열: 50, 20, 35, 60
세번째 부분배열: 10, 45, 65, 5
네번째 부분배열: 40, 55, 80, 70
이렇게 거리가 4씩 떨어진 데이터들로 구성해본다. 각 부분배열에 대해 삽입 정렬을 적용하여 정렬해주면,

1. [30, 75], 25, 15
2. [25, 30, 75], 15
3. [15, 25, 30, 75]
   첫번째 부분배열은 위와 같은 비교, 교환이 된다. 부분배열의 관점에선 삽입할 데이터가 한 칸 떨어져 있는 이웃한 데이터와 비교하고 위치 교환을 한 것처럼 보이지만 입력 배열의 관점에서 보면 {15, ..., ..., ..., 25, ..., ..., ..., 30, ..., ..., ..., 75, ..., ..., ...} 이 된다.
   즉 부분배열에서 한 칸 떨어진 이웃한 데이터와 교환,비교는 전체 입력 배열에서 4칸 떨어진 데이터와 비교하고 교환하는 것이 되는 것이다. 그래서 삽입할 위치를 찾기 위해 삽입 정렬처럼 한 칸씩 이동하는 것에 비하면 한 번에 여러 칸을 이동하므로 빠른 속도로 제자리를 찾을 수 있다.
   이후 4개의 부분정렬에서 삽입 정렬이 완료되면 부분 정렬된 배열 전체를 다시 2개의 부분 배열로 나누어 삽입 정렬을 수행하고 최종적으로 배열 전체를 하나의 부분배열로 간주하여 삽입 정렬을 적용하여 결과를 얻는다.

부분배열의 개수와 크기를 변화시키는 방법에 따라 다른 성능을 보이게 된다.
부분배열의 개수를 정하기 위해 양수로 이루어진 임의의 순열 h1, h2, ... 를 정하고 적절한 hk부터 역순으로 차례데러 적용한다. 따라서 셸 정렬의 첫 번째 단계에서는 입력 배열 전체를 hk개의 부분배열로 나누어 삽입 정렬을 수행하고 두 번째 단계에선 부분 정렬된 배열 전체를 hk-1 개의 부분배열로 나누어 삽입 정렬을 수행해주며 반복하다가 마지막 단계에선 h1 = 1개의 부분배열(전체 배열)을 삽입 정렬해준다.

\*hk는 부분배열의 개수뿐 아니라 각 부분배열 내에서 이웃한 데이터 간의 거리(간격의 크기)도 함께 나타낸다.

```
ShellSort(A[], n)
입력 A[0..n-1] 입력 배열
n 입력 크기
출력 A[0..n-1] 정렬된 배열
{
for (D=floor(n/2);D>=1;D=floor(D/2)) { -> D는 부분배열의 개수&간격 크기
for(i=D;i<n;i++) { -> D개의 부분배열에 대한 삽입 정렬
val = A[i];
for (j=i; j>=D && A[j-D]>val; j=j-D) {
A[j] = A[j-D];
}
A[j] = val;
}
}
return (A);
}
```

전체 배열을 부분배열로 나눈다고해서 실제로 각 부분배열을 위한 별도 메모리를 지정하는 것이 아니다.
원래 배열 내에서 간단히 인덱스 조작을 통해 원하는 데이터에 접근하도록 하여 부분배열의 개념을 구현해낸다.

ex. 셸 정렬 예시
A[] = {30, 50, 10, 40, 75, 20, 45, 55, 25, 35, 65, 80, 15, 60, 5, 70}
\*D를 결정하기 위한 순열(1, 2, 4, 8, ...) 대신 1, 4, 13, 40, 121, ... 을 사용

첫 번째 D를 결정하고자 할 때 입력 크기(n)가 16보다 작으면서 가장 큰 값을 찾으면 13이되므로 D는 13, 4, 1 을 순서대로 적용한다.

1. D = 13
   입력 배열에서 인접한 두 데이터 간 거리가 13이 되도록 데이터를 구분하여 13개의 부분배열로 나누고 각 부분배열을 삽입 정렬
   30, ..., 60 -> 변경X
   50, ..., 5 -> 변경O
   10, ..., 70 -> 변경X
   -> 30, 5, 10, 40, 75, 20, 45, 55, 25, 35, 65, 80, 15, 60, 50, 70

2. D = 4
   30, ..., 75, ..., 25, ..., 15 -> 15 25 30 75
   5, ..., 20, ..., 35, ..., 60 -> 변경X
   10, ..., 45, ..., 65, ..., 50 -> 10 45 50 65
   40, ..., 55, ..., 80, ..., 70 -> 40 55 70 80
   -> 15, 5, 10, 40, 25, 20, 45, 55, 30, 35, 50, 70, 75, 60, 65, 80

3. D = 1(전체 배열이 부분배열)
   -> 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80

- 부분배열(D)을 계산하는 방식인 사용되는 순열에 따라 성능이 달라짐

  - 셸 정렬은 D를 반복적으로 변화시키면서 삽입 정렬을 적용하는 방법
  - 최적의 간격을 찾는 문제는 풀리지 않은 문제로 남아있고, 위에서 소개한 알고리즘에선 주어진 입력 배열의 크기의 1/2을 초기 D로 지정함
  - 사용되는 D의 순열에는
    - 1, 4, 13, 40, 121, 364, ...
    - 1, 3, 5, 7, 15, 31, ...
    - 1, 3, 7, 21, 48, 112, ...
    - 1, 4, 10, 23, 57, 132, ...
  - 순열의 역순으로 사용하는데, 입력 크기보다 작으면서 가장 큰 값을 D로 지정해준다. (첫번째 순열을 사용한다고 했을 때 입력 크기 n이 100이라면, 40부터 사용해준다)

- O(n^2) 시간 복잡도를 가지나 최선의 경우엔 O(nlogn)이 되기도 함

- 안정적이지 않은 정렬 알고리즘

  - 정렬 전의 동일한 데이터의 상대적 순서가 정렬 후에 유지되지 못함

- 제자리 정렬 알고리즘
  - 입력 배열을 위한 공간 외 별도로 필요한 저장 공간은 상수 개임

### 퀵 정렬

배열 내 특정 데이터를 기준으로 정렬할 데이터들을 적당히 이동시켜 조건을 만족하도록 오른쪽 부분배열과 왼쪽 부분배열로 나눈다.

- 왼쪽 배열에 있는 데이터는 오른쪽 부분배열에서 가장 작은 데이터보다 작다
- 오른쪽 부분배열에 있는 데이터는 왼쪽 부분배열에서 가장 큰 데이터보다 크다
  위 조건에 맞춰 두 부분배열로 나누면 양쪽 부분배열에 공통으로 속하는 데이터가 존재하지 않고 서로 독립적인 배열이 되므로 각 부분배열에 대해 독립적으로 퀵 정렬을 순환적으로 적용하여 배열 전체를 정렬한다.

즉 퀵 정렬은 특정 데이터를 기준으로 주어진 배열을 2개의 부분배열로 분할하고 각 부분배열에 대해 퀵 정렬을 순환적으로 적용하는 방식이다.

퀵 정렬에서 배열을 분할하는 기준이 되는 특정 데이터를 피벗(=분할 원소)라 부르며 배열 내의 임의의 데이터가 피벗이 될 수 있지만 간단히 배열의 첫 번째 데이터를 피벗으로 정한다. 피벗을 기준으로 2개의 부분배열로 나누는 것은 피벗이 정렬될 제 위치를 찾아 이동하고 이를 기준으로 피벗보다 작은 데이터와 큰 데이터를 구분하기 위함이다.

피벗이 제 위치를 잡으면 입력 배열은 왼쪽 배열, 피벗, 오른쪽 배열로 정렬되고 정렬되지 않은 왼쪽, 오른쪽 부분배열에 대해 각각 분할을 순환적으로 적용한다.

ex. 퀵 정렬 예시
A[] = {30, 45, 20, 15, 40, 25, 35, 10}

1. 피벗 지정 후 분할
   피벗: 30
   배열의 양 끝에서부터 중앙을 향하여 동시에 검색하면서 각각 피벗보다 큰 데이터와 작은 데이터를 찾기 위한 Left, Right 변수를 초기화
   Left: 피벗 바로 다음 데이터 위치
   Right: 배열의 맨 마지막 데이터 위치
2. 현재 위치부터 Left를 오른쪽으로 하나씩 이동하면서 피벗보다 큰 데이터 위치를 찾으면 Left 에 입력
   Left = 1 (40)
   Right를 왼쪽으로 하나씩 이동하면서 피벗보다 작은 데이터 위치를 찾으면 입력
   Right = 7
   이때 Left < Right 이므로 A[Left] 와 A[Right] 를 서로 교환해준다.
   30, 10, 20, 15, 40, 25, 35, 45
3. 2번 과정을 계속하다보면
   Left = 4
   Right = 5 가 되고 Left < Right 이므로 서로 교환해준다.
   30, 10, 20, 15, 25, 40, 35, 45
4. Left = 4, Right = 5 에서 왼쪽/오른쪽으로 이동하면서 피벗보다 크고/작은 데이터의 위치를 찾는다.
   Left = 5, Right = 4
   앞선 과정과 다르게 Left > Right 이므로 피벗 A[0]과 A[Right]를 서로 교환한다.
   25, 10, 20, 15, 30, 40, 35, 45
5. 분할 과정의 마지막으로 피벗과 A[Right]를 교환하면 피벗을 기준으로 왼쪽 부분배열에는 피벗보다 작은 데이터들이, 오른쪽 부분배열에는 피벗보다 큰 데이터들로 분할 됨을 알 수 있다.

```
QuickSort(A[], n)
입력 A[0..n-1] 정렬할 배열
n 입력 크기
출력 A[0..n-1] 정렬된 배열
{
if (n > 1) {
// 피벗을 기준으로 두 부분 배열로 분할
pivot = Partition(A[0..n-1], n);

    // 왼쪽 부분배열에 대한 퀵 정렬 순환 호출
    QuickSort(A[0..pivot-1], pivot);
    // 오른쪽 부분배열에 대한 퀵 정렬 순환 호출
    QuickSort(A[pivot+1..n-1], n-pivot-1);

}
}

int Partition(A[], n) {
Left = 1;
Right = n-1;
while (Left < Right) {
// 오른쪽으로 진행하면서 피벗A[0] 보다 큰 값의 위치를 찾음
while (Left < n && A[Left] < A[0]) Left++;

    // 왼쪽으로 진행하면서 피벗A[0] 보다 작은 값의 위치를 찾음
    while (Right > 0 && A[Right] > A[0]) Right++;

    if (Left < Right)
      A[Left] 와 A[Right] 위치 교환
    else
      피벗 A[0] 와 A[Right] 위치 교환

}
}
```

ex. 퀵 정렬 예시 2
A[] = {30, 50, 17, 40, 88, 15, 44, 55, 22, 11, 66, 13, 85}

1. Partition 함수를 적용하여 피벗이 제자리를 잡고 두 부분배열로 분할해준다.
   A[0] 를 피벗으로 잡고 Left = 1, Right = n-1 = 12 로 초기화
   Left 는 오른쪽으로 이동하면서 30보다 큰 값의 위치를 찾음 -> A[1] 50
   Right 는 왼쪽으로 이동하면서 30보다 작은 값의 위치를 찾음 -> A[11] 13
2. 두 위치를 찾은 Left, Right 를 비교하고 Left < Right 이므로 A[Left]와 A[Right] 를 교환
   {30, 13, 17, 40, 88, 15, 44, 55, 22, 11, 66, 50, 85}
   3, 4. 2번 과정을 반복
   {30, 13, 17, 11, 88, 15, 44, 55, 22, 40, 66, 50, 85}
   {30, 13, 17, 11, 22, 15, 44, 55, 88, 40, 66, 50, 85}
3. Left > Right 가 되는 시점에서 A[0] 과 A[Right] 를 서로 교환해준다.
   {15, 13, 17, 11, 88, 30, 44, 55, 22, 40, 66, 50, 85}
   {15, 13, 17, 11, 88} 30 {44, 55, 22, 40, 66, 50, 85} -> 피벗을 중간으로 분할되어 두 개의 부분배열로 나눠진다.
4. 나눠진 부분배열에서 위의 과정을 반복해준다.
   {15, 13, 11, 17, 88} 30 {44, 55, 22, 40, 66, 50, 85}
   {11, 13, 15, 17, 88} 30 {40, 55, 22, 44, 66, 50, 85}
   {11, 13} 15 {17, 88} 30 {40, 55, 22} 44 {66, 50, 85}
   {11, 13} 15 {17, 88} 30 {40, 22, 55} 44 {66, 50, 85}
   11, 13, 15, 17, 88, 30, 22, 40, 55, 44, 66, 50, 85
   11, 13, 15, 17, 22, 30, 40, 44, 50, 55, 66, 85, 88

- 분할 함수(Partition)의 성능은 ⍬(n)이다.
  - Partition 함수에서 피벗 A[0]를 제외한 나머지 n-1개의 데이터는 피벗과 한 번 또는 기껏해야 두 번의 비교를 수행하기 때문에 입력 크기 n에 비례한다.
- 퀵 정렬의 수행시간은 Partition 함수+왼쪽 부분배열+오른쪽 부분배열의 합으로 표현된다.
  - T(n) = T(nL) + T(nR) + ⍬(n)
  - nL + nR = n-1
  - 즉 두 부분배열의 크기에 따라 Partition 함수의 호출 횟수가 달라지므로 수행시간이 달라진다.
  - 퀵 정렬의 시간 복잡도는 최악의 경우, 최선의 경우, 평균적인 경우로 구분해야 한다.
- 퀵 정렬의 최악의 수행시간은 O(n^2)
  - T(n) = T(n-1) + T(0) + ⍬(n) => O(n^2)
  - 모든 단계에서 피벗이 최솟값으로 왼쪽 혹은 오른쪽 부분배열에 아무런 데이터가 없이 모든 데이터가 한쪽의 부분배열에 위치하여 (오름차순/내림차순 정렬이 된 경우) 극심한 불균형적인 분할이 있는 경우 분할을 수행할 때마다 피벗이 최솟값/최댓값이 되어 분할이 항상 0:n-1/n-1:0으로 이루어져 데이터를 정렬하는 과정에서 가장 많은 횟수의 분할 함수가 호출된다.
- 퀵 정렬의 최선의 수행시간은 O(nlogn)
  - 가장 균형적으로 분할이 이루어지는 경우로 가장 적게 분할 함수가 수행된다.
  - T(n) = T(n/2) + T(n/2) + ⍬(n) => O(nlogn)
- 퀵 정렬의 평균 수행시간은 O(nlogn)
- 피벗 선택의 임의성만 보장되면 퀵 정렬은 최악의 수행시간이 아닌 평균 수행시간을 보장한다.
  - 퀵 정렬의 경우 입력 배열이 오름차순/내림차순으로 정렬된 상태에서 배열의 첫 번째 원소가 피벗으로 지정되면 피벗은 항상 최솟값/최대값이 될 수밖에 없고 이를 기준으로 분할을 수행하면 피벗만 제자리를 잡고 그외의 나머지 데이터가 하나의 부분배열이 되는 극심한 불균형적인 분할이 된다.그러므로 피벗을 정할 때 첫 번째 원소가 아닌 난수 발생기를 통해 임의로 선택하게 된다면 피벗이 최솟값/최댓값이 될 가능성이 낮아져서 최악의 경우가 발생할 가능성도 적어지게 될 것이다.
- 분할 정복 방법이 적용된 알고리즘이다.
  - 주어진 문제를 순환적으로 독립적인 소문제로 분할하여 해결하는 분할정복 방법이 적용되어 있다.
  1. 분할: 피벗을 기준으로 주어진 배열을 두 부분배열로 분할
  2. 정복: 두 부분배열에 대해 퀵 정렬을 순환적으로 적용하여 정렬
  3. 결합: 필요 없음
- 안정적이지 않은 정렬 알고리즘이다.
  - 동일한 값의 키를 가지고 있는 요소에 대해 퀵 정렬을 수행하면 상대적인 위치가 유지되지 못하기 때문에 안정적이지 않은 정렬 알고리즘이다.
- 제자리 정렬 알고리즘이다.

### 합병 정렬

분할정복 방법이 적용된 정렬 알고리즘으로 두 부분배열의 크기를 항상 같게 분할해주는 점이 퀵 정렬과 차이가 있다.
주진 배열을 동일한 크기의 두 부분배열로 분할하고 각 부분배열에 대해 순환적으로 합병 정렬을 적용하여 정렬시킨 다음 정렬된 두 부분배열을 결합(합병)하여 하나의 정렬된 배열을 만드는 방식의 정렬 알고리즘이다.

ex. 합병 정렬의 예시
A[] = {60, 20, 70, 10, 80, 30, 50, 40}

1. {60, 20, 70, 10} / {80, 30, 50, 40} 으로 분할
2. 각 부분배열에 대해 합병 정렬을 순환적으로 적용하여 {10, 20, 60, 70} / {30, 40, 50, 80} 을 얻는다
3. 정렬된 두 부분배열을 합쳐서 최종적으로 정렬된 배열을 생성한다

2번의 과정에서 한 번의 순환 호출마다 절반씩 줄어든 크기 n/2인 배열에 대해 1~3의 과정을 거치게 된다.

퀵 정렬에선 피벗을 기준으로 왼쪽/오른쪽 부분배열로 나누는 것이 핵심이었으나 합병 정렬에선 2개의 부분배열로 나누는 것은 단순한 작업에 불과하고 3에 해당하는 정렬된 두 부분배열을 하나의 정렬된 배열로 합치는 합병 과정을 이해하는 것이 핵심이다.

#### 합병 과정

합병할 두 부분배열 B[], C[]는 이미 정렬된 상태이므로 각 부분배열의 가장 왼쪽 데이터부터 차례대로 서로 비교하여 작은 데이터를 선택한 뒤 A[]에 저장하고 배열 A[]에 저장된 작은 데이터가 속한 부분배열의 인덱스를 1 증가시켜 다음 데이터를 비교 대상으로 지정한다. 각 부분배열의 두 데이터를 비교하여 작은 데이터를 배열 A[]로 저장하는 과정을 반복하다보면 한쪽 부분배열의 모든 데이터는 A[]에 저장되지만 다른 부분배열은 처리되지 못한 데이터가 남게되는데 남는 모든 데이터를 차례대로 선택하여 A[]에 저장하는 과정을 합병 과정이라 한다.

```
MergeSort(A[], n)
입력 A[0..n-1] 정렬할 배열
n 입력 크기
출력 A[0..n-1] 정렬된 배열
{
if (n>1) {
Mid = floor(n/2);

    B[0..Mid-1] = MergeSort(A[0..Mid-1], Mid);
    C[0..n-Mid-1] = MergeSort(A[Mid..n-1], n-Mid);

    A[0..n-1] = Merge(B[0..Mid-1], C[0..n-Mid-1], Mid, n-Mid);

}
return (A);
}
```

---

---

## 순차 탐색 알고리즘

```
SequentialSearch(A[], n, key)

입력
A[0..n-1]
n 배열크기
key 탐색 키

출력
key가 배열 내 존재하면 해당 인덱스, 아니면 n

{
i = 0;
while (i < n && A[i] != key)
i = i + 1
return (i);
}

1. 첫 번째 숫자부터 확인하여 탐색 키와 동일한 숫자가 나올 때까지 비교

## 이진 탐색 알고리즘

입력데이터가 정렬된 경우 순차 탐색보다 효율적인 방식

```

BinarySearch(A[], key, Left, Right)

A[Left..Right]
key 탐색 키

출력
key가 A[] 내에 존재하면 해당 인덱스, 아니면 -1 반환

{
if (Left > Right) return (-1);
Mid = floor((Left+Right)/2);
if (A[Mid] == key) return (Mid);
else if (key < A[Mid]) BinarySearch(A, key, Left, Mid-1);
else BinarySearch(A, key, Mid+1, Right);
}

```

1. 주어진 배열에서 중앙 위치를 계산(Mid)
2. 중앙 위치의 값과 탐색 키를 비교하여 원하는 값이면 탐색을 종료
3. 그렇지 않다면 중앙 값과 탐색 키를 비교하여 이진 탐색을 순환 호출
4. 탐색 키가 중앙 값보다 작으면 정렬된 배열의 왼쪽 절반을 이진 탐색 순환 호출(Left~Mid-1)
5. 탐색 키가 중앙 값보다 크면 정렬된 배열의 오른쪽 절반을 이진 탐색 순환 호출(Mid+1~Right)

## 배열에서 가장 작은 값을 찾는 알고리즘

arr[] = {80, 50, 30, 10, 40, 90}
주어진 데이터에 대해 최솟값(/최댓값)을 찾는 기본적인 방법은 각 숫자를 차례대로 하나씩 비교하는 것

1. 입력 배열 중 첫 번째 데이터를 최솟값으로 지정
2. 배열에서 다음 숫자를 읽고 앞서 저장된 최솟값을 비교
3. 비교 후 더 작은 숫자를 최솟값으로 다시 지정
4. 배열에 처리할 데이터가 남아 있으면 2로 이동
5. 저장된 최솟값을 결과로 출력

## 오일러 경로

그래프의 모든 간선을 오직 한 번만 지나가는 경로를 찾는 문제

1. 각 정점의 차수가 홀수인 정점이 없거나 2개
2. 차수가 홀수인 정점이 2개인 경우 홀수 정점에서 시작해야 함
3. 홀수 정점이 0개인 경우 출발점과 도착점이 같은 오일러 경로가 됨 = 오일러 회로

## 데이크스트라 알고리즘

하나의 출발점을 기준으로 다른 모든 정점으로의 최단 경로를 구하는 문제

## 플로이드 알고리즘

임의의 두 도시 간 최단 경로를 찾는 문제
```
