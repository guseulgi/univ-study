# 지능

배우거나 이해하는 능력, 또는 새로운 상황에 대처하는 능력
새로운 대상이나 상황에 부딪혀 그 의미를 이해하고 합리적인 적응 방법을 알아내는 지적 활동의 능력

문제를 해결하기 위한 일반화된 지식을 알아내고 이를 문제해결에 적용하는 지능적 능력

앨런 튜링의 튜링 테스트: 사람인지 컴퓨터인지 알 수 없도록 가려진 상대방과 대화하여 그 상대방이 사람이 맞는지 구분해 내는 테스트

# 인공지능

지능적 행동의 일반적 의미에 대한 컴퓨터 관점에서의 이해 및 지능적 행동을 할 수 있는 인공물의 생성을 다루는 컴퓨터과학의 분야

인공지능의 탐구는 계산심리학 관점에서 접근과 기계지능 관점에서 접근이 함께 이루어지고 있다.

1. 계산심리학: 사람과 동일한 방식으로 행동하는 컴퓨터 프로그램을 만듦으로써 인간의 지능적 행동을 이해하는 것
2. 기계지능: 컴퓨터를 이용하여 프로그래밍할 수 있는 영역을 인간이 수행할 수 있는 작업 영역으로 확장하는 것 - 과제 지향적

# 인공지능 구현을 위한 접근 방법

인공지능을 구현하기 위해 다양한 접근 방법을 시도

1. 기호(symbol)처리 방식
   초기 인공지능 연구에서 가장 주목했던 것

- 물리적 기호 시스템 가설: 일반적인 지능적 행동을 위한 필요 충분한 수단을 가지고 있다 = 즉 인간이 행하는 지능적 작업을 수행하는 프로그램을 작성할 수 있다는 믿음의 근원

물리적 기호 시스템은 실체의 집합과 절차의 집합을 포함한다.
실체는 물리적 패턴을 나타내는 기호 또는 이들을 결합한 표현
어떠한 표현은 생성, 수정 재생산, 파괴 등의 절차에 따라 다른 표현으로 변환된다.

이러한 기호처리 시스템 형태가 전문가 시스템으로 구현됐다.
전문가 시스템: 특정한 문제 분야에 한정된 지식을 이용한 인공지능 시스템을 구현하려는 것

2. 확률 및 통계 이론
   추론의 근거가 되는 사실이나 규칙 등에 불확실성이 내재하는 경우 주어진 데이터 집합을 바탕으로 미래의 현상을 예측하거나 객체를 분류하는 문제를 해결해야 하는 경우 활용

- 자연어 처리
- 머신러닝
- 패턴 인식
- 회귀 분석 (선형회귀, 로지스틱 회귀)
- 베이즈 분류기
- 결정트리
- 서포트 벡터 머신
- 군집화 알고리즘

3. 연결주의 방법
   사람이나 고등동물의 두뇌를 구성하는 신경 체계가 매우 많은 신경세포가 서로 연결되어 신호를 교환함으로써 지능적으로 판단하고 행동하는 것을 인공지능에 접목하기 위한 시도

연결주의 방법으로 설계된 계산 구조를 인공 신경망이라 한다.
인공 신경망 모델을 설계하고 주어진 문제에 맞게 학습하기 위한 이론과 기술을 연구하는 분야를 딥러닝이라 한다.

# 문제풀이

특별히 주어진 문제를 해결하는 일반적인 방법을 연구
인공지능에선 관심을 기울이는 문제는 알고리즘으로 구현할 수 있는 효율적이고 완전한 해가 발견되지 않은 문제로 시행착오적 방법이다.
즉 해가 놓인 방대한 공간에서 그 중 하나 해를 탐색함으로 써 문제를 풀게 된다.

인공지능의 처리는 사람의 머릿속이 아닌 컴퓨터를 통해 구현되어야 하므로 주어진 문제의 상태와 문제풀이를 위한 연산을 컴퓨터에서 처리할 수 있는 형태로 나타내야 한다.

# 8 퍼즐 문제

## 문제의 표현

1. 상태
   문제풀이 과정에서 나타날 수 있는 퍼즐의 모습
2. 초기상태
   최초 퍼즐의 모습
3. 목표상태
   목표 퍼즐의 모습
4. 연산자
   문제의 상태를 변화시키는 역할을 하는 것
   퍼즐 문제를 풀기 위해선 적당한 순서로 빈칸을 이동하는 것이 필요하다.

문제: 초기상태->목표상태
풀이할 문제는 (초기상태, 연산자 집합, 목표상태)로 표현할 수 있으며 문제를 풀이하는 것은 초기상태에서 시작하여 목표상태가 되도록 상태를 변화시키는 연산자의 적용순서를 찾는 것이다.

## 상태묘사

풀이하고자 하는 문제의 상태를 컴퓨터로 처리하기 위한 적절한 자료구조로 표현한 것
기호 열, 벡터, 다차원 배열, 트리, 리스트 등

예를 들어 산술식을 표현하려면 이진트리를 이용할 수 있다.
8 퍼즐 문제에선 가로세로로 나열된 조각들의 배치형태가 상태이며 2차원 배열을 이용하여 표현하는 것이 자연스럽다.
빈칸의 위치를 나타내는 값을 저장하게 하여 퍼즐 조각을 이동시키는 연산자를 쉽게 구현할 수 있다.

```
struct PuzzleState {
   int blankX, blankY; // 빈칸의 위치 좌표 (x, y)
   char board[3][3];
};
```

## 연산자

문제의 어느 한 상태를 다른 상태로 변환시키기 위해 사용, 일종의 함수

가능한 모든 입력 상태묘사에 대해 가능한 모든 출력 상태묘사를 저장한 목록을 이용하여 연산자를 정의하는 것은 비실용적이다.
일반적으로 연산자를 하나의 상태묘사를 다른 상태묘사로 변화시키는 일종의 연산능력을 지닌 함수로 가정한다.

어떤 문제의 상태묘사를 문자열 형태로 하는 경우 연산자는 생성규칙/되쓰기 법칙을 사용한다.
일련의 생성 규칙들은 어떻게 하나의 문자열이 다른 문자열로 변환될 것인가를 정의해 준다.
