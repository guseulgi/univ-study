# 지능

배우거나 이해하는 능력, 또는 새로운 상황에 대처하는 능력
새로운 대상이나 상황에 부딪혀 그 의미를 이해하고 합리적인 적응 방법을 알아내는 지적 활동의 능력

문제를 해결하기 위한 일반화된 지식을 알아내고 이를 문제해결에 적용하는 지능적 능력

앨런 튜링의 튜링 테스트: 사람인지 컴퓨터인지 알 수 없도록 가려진 상대방과 대화하여 그 상대방이 사람이 맞는지 구분해 내는 테스트

# 인공지능

지능적 행동의 일반적 의미에 대한 컴퓨터 관점에서의 이해 및 지능적 행동을 할 수 있는 인공물의 생성을 다루는 컴퓨터과학의 분야

인공지능의 탐구는 계산심리학 관점에서 접근과 기계지능 관점에서 접근이 함께 이루어지고 있다.

1. 계산심리학: 사람과 동일한 방식으로 행동하는 컴퓨터 프로그램을 만듦으로써 인간의 지능적 행동을 이해하는 것
2. 기계지능: 컴퓨터를 이용하여 프로그래밍할 수 있는 영역을 인간이 수행할 수 있는 작업 영역으로 확장하는 것 - 과제 지향적

# 인공지능 구현을 위한 접근 방법

인공지능을 구현하기 위해 다양한 접근 방법을 시도

1. 기호(symbol)처리 방식
   초기 인공지능 연구에서 가장 주목했던 것

- 물리적 기호 시스템 가설: 일반적인 지능적 행동을 위한 필요 충분한 수단을 가지고 있다 = 즉 인간이 행하는 지능적 작업을 수행하는 프로그램을 작성할 수 있다는 믿음의 근원

물리적 기호 시스템은 실체의 집합과 절차의 집합을 포함한다.
실체는 물리적 패턴을 나타내는 기호 또는 이들을 결합한 표현
어떠한 표현은 생성, 수정 재생산, 파괴 등의 절차에 따라 다른 표현으로 변환된다.

이러한 기호처리 시스템 형태가 전문가 시스템으로 구현됐다.
전문가 시스템: 특정한 문제 분야에 한정된 지식을 이용한 인공지능 시스템을 구현하려는 것

2. 확률 및 통계 이론
   추론의 근거가 되는 사실이나 규칙 등에 불확실성이 내재하는 경우 주어진 데이터 집합을 바탕으로 미래의 현상을 예측하거나 객체를 분류하는 문제를 해결해야 하는 경우 활용

- 자연어 처리
- 머신러닝
- 패턴 인식
- 회귀 분석 (선형회귀, 로지스틱 회귀)
- 베이즈 분류기
- 결정트리
- 서포트 벡터 머신
- 군집화 알고리즘

3. 연결주의 방법
   사람이나 고등동물의 두뇌를 구성하는 신경 체계가 매우 많은 신경세포가 서로 연결되어 신호를 교환함으로써 지능적으로 판단하고 행동하는 것을 인공지능에 접목하기 위한 시도

연결주의 방법으로 설계된 계산 구조를 인공 신경망이라 한다.
인공 신경망 모델을 설계하고 주어진 문제에 맞게 학습하기 위한 이론과 기술을 연구하는 분야를 딥러닝이라 한다.

---

# 문제풀이

특별히 주어진 문제를 해결하는 일반적인 방법을 연구
인공지능에선 관심을 기울이는 문제는 알고리즘으로 구현할 수 있는 효율적이고 완전한 해가 발견되지 않은 문제로 시행착오적 방법이다.
즉 해가 놓인 방대한 공간에서 그 중 하나 해를 탐색함으로 써 문제를 풀게 된다.

인공지능의 처리는 사람의 머릿속이 아닌 컴퓨터를 통해 구현되어야 하므로 주어진 문제의 상태와 문제풀이를 위한 연산을 컴퓨터에서 처리할 수 있는 형태로 나타내야 한다.

# 8 퍼즐 문제

## 문제의 표현

1. 상태
   문제풀이 과정에서 나타날 수 있는 퍼즐의 모습
2. 초기상태
   최초 퍼즐의 모습
3. 목표상태
   목표 퍼즐의 모습
4. 연산자
   문제의 상태를 변화시키는 역할을 하는 것
   퍼즐 문제를 풀기 위해선 적당한 순서로 빈칸을 이동하는 것이 필요하다.

문제: 초기상태->목표상태
풀이할 문제는 (초기상태, 연산자 집합, 목표상태)로 표현할 수 있으며 문제를 풀이하는 것은 초기상태에서 시작하여 목표상태가 되도록 상태를 변화시키는 연산자의 적용순서를 찾는 것이다.

## 상태묘사

풀이하고자 하는 문제의 상태를 컴퓨터로 처리하기 위한 적절한 자료구조로 표현한 것
기호 열, 벡터, 다차원 배열, 트리, 리스트 등

예를 들어 산술식을 표현하려면 이진트리를 이용할 수 있다.
8 퍼즐 문제에선 가로세로로 나열된 조각들의 배치형태가 상태이며 2차원 배열을 이용하여 표현하는 것이 자연스럽다.
빈칸의 위치를 나타내는 값을 저장하게 하여 퍼즐 조각을 이동시키는 연산자를 쉽게 구현할 수 있다.

```
struct PuzzleState {
   int blankX, blankY; // 빈칸의 위치 좌표 (x, y)
   char board[3][3];
};
```

## 연산자

문제의 어느 한 상태를 다른 상태로 변환시키기 위해 사용, 일종의 함수

가능한 모든 입력 상태묘사에 대해 가능한 모든 출력 상태묘사를 저장한 목록을 이용하여 연산자를 정의하는 것은 비실용적이다.
일반적으로 연산자를 하나의 상태묘사를 다른 상태묘사로 변화시키는 일종의 연산능력을 지닌 함수로 가정한다.

어떤 문제의 상태묘사를 문자열 형태로 하는 경우 연산자는 생성규칙/되쓰기 법칙을 사용한다.
일련의 생성 규칙들은 어떻게 하나의 문자열이 다른 문자열로 변환될 것인가를 정의해 준다.

생성 규칙은 Si -> Sj 형태로 나타내며 문자열 Si가 문자열 Sj로 변환될 수 있음을 의미한다.
예를 들어 A$ -> B$ 는 어느 문자열의 처음에 나타나는 기호 A는 다른 B로 대치될 수 있음을 나타낸다. ($ 부호는 빈 문자열을 포함한 부분 문자열을 나타낸다)

8 퍼즐의 예에서는 빈칸의 움직임에 따라 전부 4개의 연산자를 정의할 수 있다.
즉 빈칸의 상하좌우 이동이 있을 수 있어 경우에 따라 어느 상태에서는 가해질 수 없는 연산자도 있다.

```
// 빈칸을 위로 이동하는 연산자
int opMvBlnkUp(PuzzleState* s) {
   if (s->blankY > 0) {
      s->board[s->blankX][s->blankY] = s->board[s->blankX][s->blankY-1];
      s->board[s->blankX][--s->blankX] = ' ';
      return 1;
   } else {
      return 0;
   }
}
```

# 상태공간

초기상태로부터 적용 가능한 연산자를 적용하여 얻을 수 있는 모든 상태의 집합
통상적으로 우리가 다루는 문제는 극히 크거나 무한에 가까운 상태공간을 갖는 것이 보통이다.

상태공간을 표현하는 방법으로는 방향성 그래프가 많이 사용된다.

## 상태공간을 나타내기 용이한 방향 그래프

유한한/무한한 개수의 노드로 구성
노드들은 Arc 로 연결되어 각 아크는 어느 한 노드로부터 다른 노드로 방향이 주어져 있으며 이러한 그래프를 방향성 그래프라고 한다.

아크가 노드 Np로부터 노드 Ns 로 향하고 있다면 Ns는 노드 Np의 후계(successor)라고 하고 노드 Np는 노드 Ns의 부모라고 한다.

즉 그래프가 상태공간을 나타내기 위해 사용될 때 그래프의 노드는 상태묘사를 나타내고 아크들은 연산자를 나타낸다.

노드 Ni가 N(i-1)의 후계노드라고 하면 일련의 노드 N0, N1, ... Nk는 노드 N0부터 노드 Nk까지의 길이가 k인 경로라고 한다.
노드 Ni부터 노드 Nj까지 어떤 경로가 존재한다면 Nj는 노드 Ni의 자손이라 하며 노드 Nj는 노드 Ni로부터 도달할 수 있다(=연결됨)라고 한다.

# 탐색

상태공간에서의 탐색과정은 정해진 기준에 따라 어떠한 상태를 선택한 후 적용 가능한 연산자를 사용하여 새로운 상태를 생성하는 과정을 반복하는 것이다.
탐색과정이 끝났는가에 대한 결정은 새로 생성된 상태묘사가 목표상태를 묘사하고 있는지 검토하는 단순한 정합에 의해 행해지기도 하지만 때론 복잡한 목표상태 테스트로 행해지기도 한다.

어떤 문제에 대한 최적의 해를 구하는 문제에선 단순히 목표까지의 경로를 찾는 것만으론 충분하지 않고 이러한 유형의 문제에서는 주어진 기준에 따르는 최적의 경로를 찾아야 한다.
이를 최적해라고 하며 최적해를 찾을 때까지 탐색 과정을 계속한다.

# 문제의 상태공간 표현

1. 상태묘사의 형태
2. 초기상태에 대한 묘사
3. 연산자의 종류와 이들이 각각 상태묘사에 미치는 영향
4. 목표상태에 대한 묘사

# 물병 문제

눈금이 없는 물통에 지정된 양의 물을 채우는 문제

Q. 눈금이 없는 4L들이 물병과 3L들이 물병이 1개씩 있고 항상 물을 공급할 수 있는 펌프가 있을 때 4L 물병에 정확히 2L 물을 채우려면

1. 상태묘사
   각각의 물병에 들어 있는 물의 양이 상태가 된다.
   4L, 3L 물병에 들어 있는 물의 양을 x, y라고 하면 물병문제의 상태는 (x, y)로 표현 가능하다.

2. 연산자
   물병문제에서 연산자는

1) 펌프로 물병에 물을 채우기
2) 한 물명에 있는 물을 다른 물병으로 옮기기
3) 물병에 있는 물을 버리기
   다만 물병에 눈금이 없으므로 임의의 양의 물을 옮기는 연산자는 정의할 수 없을 것이다.

3. 초기상태 및 목표상태
   초기상태는 두 물병이 비어 있는 상태이고 목표상태는 4L 물병에 2L 물이 들어 있는 상태이다.
   즉, 초기상태는 (0, 0) 목표상태는 (2, y)로 묘사할 수 있다.

# 외판원 문제

외판원이 N개의 도시를 각각 한 번씩 방문한 뒤 출발했던 도시로 되돌아오는 문제
가장 짧은 거리를 지나는 경로를 이용할 것으로 기대된다.
그래프를 사용하여 상태공간을 표현하는데 유용하다.

1. 상태묘사
   상태는 그때까지 방문한 도시의 리스트로 묘사된다.
   같은 도시가 한 번 이상 포함된 리스트는 허용되지 않는다. 다만 출발 도시를 마지막에 한 번더 포함될 수 있다.

2. 연산자
   각 도시로 이동하는 행동으로 정의
   현재의 상태묘사에 적용했을 때 정당한 차후의 상태묘사로 변화할 수 없는 연산자는 적용할 수 없다.

3. 초기상태 및 목표상태
   초기상태는 출발도시에서 시작하는 상태로 묘사
   목표상태는 초기상태로 끝나면서 모든 도시의 이름을 포함한다.
   아크에 가중치(이동거리 등)가 표시되어 있다면 최단경로 탐색에 적용해야 한다.

# 하노이 탑 문제

정해진 규칙을 준수하면서 한 말뚝에 쌓인 원판을 다른 말뚝으로 옮기는 퍼즐

3개의 말뚝 1, 2, 3이 있다. 1번 말뚝에 각각 크기가 다른 3개의 원판 A, B, C가 쌓여 있다.
가장 큰 원판 C는 제일 밑에 있고 가장 작은 원판 A는 제일 위에 있다.
원판 3개를 모두 3번 말뚝으로 옮겨라.
단 어느 말뚝이든 한 번에 제일 위에 있는 원판 1개만 옮길 수 있고 큰 원판을 작은 원판 위에 놓을 수 없다.

1. 상태묘사
   문제의 상태는 세 원판이 놓인 말뚝의 번호를 순서대로 나열한 리스트로 표현할 수 있다.
   즉 (i j k)는 가장 작은 원판 A가 말뚝 i, 원판 B가 말뚝 j에 가장 큰 원판 C가 말뚝 k에 있는 상태를 나타낸다.
   하나 이상의 원판이 같은 말뚝에 있으면 가장 큰 것이 밑에 있다고 가정한다.

2. 연산자
   지정된 원판을 현재 위치에서 목적지로 옮기는 것을 의미

연산자: 이동(ID, s, d)

- ID: 옮기고자 하는 원판
- s: 원판의 현재위치
- d: 원판을 옮길 목적지 말뚝
  즉 이동(C, 1, 2)는 원판 C를 1번 말뚝에서 2번 말뚝으로 옮기는 연산자
  이때 연산자는 옮기고자 하는 원판 위에 다른 원판이 없어야 하고 목적지 말뚝에 작은 원판이 있으면 적용할 수 없다.

3. 초기상태와 목표상태
   초기상태는 3원판이 모두 1번 말뚝에 있는 (1 1 1)
   목표상태는 모두 3번 말뚝에 있는 (3 3 3)이 된다.

# 상태공간 탐색에 의한 문제풀이

상태공간(=모든 상태 집합)에서 문제풀이는 초기상태에서 시작하여 목표상태에 도달할 수 있는 일련의 연산자를 찾는 것
이는 곧 그래프에서 이에 대응하는 경로를 찾는 문제와 동일한 것
= 노드의 집합 {S1, S2, ... Sm}의 한 노드로부터 노드의 집합 {G1, G2, ... Gn}의 한 노드까지의 경로를 찾는 것

노드 Ni로부터 Nj로 향하는 아크의 비용을 C(Ni, Nj)로 표시하면 두 노드 사이의 경로에 드는 비용은 두 노드를 연결하는 아크 비용의 합이 된다.
최적화 문제에서 두 노드를 연결하는 최소비용을 지닌 경로를 찾게 될 것이다.

연산자를 가하여 얻은 상태 중 어떤 것은 결코 목표상태로 갈 수 없는 경우도 있는데 이와 같은 시행착오를 거쳐서 목표상태를 얻는 것이 통상적인 인공지능에서의 탐색이다.
상태공간 탐색 방식은 문제 상태와 상태에 가해질 수 있는 연산자에 의하여 문제를 풀이하는 방식이다.
만일 상태공간이 매우 방대하면 탐색은 많은 시간과 자원을 소비하게 된다. 보다 효율적인 문제풀이를 하려면 탐색에 유용한 지식을 이용하여 탐색 범위를 좁히는 것이 필요하다.

# 문제축소

주어진 문제를 부분문제로 분할하여 풀이하는 것을 반복하여 각각의 부분문제를 풀이함으로써 전체문제를 해결하는 것이다.

원시문제: 축소하는 것을 반복하다보면 최후에 얻는 부분문제, 아주 단순히 해결할 수 있는 문제
주어진 문제를 더 풀기 쉬운 부분문제로 나누어 푸는 방식을 문제축소방식이라고 한다.

## 문제축소 예 - 하노이 탑 문제

1. 모든 원판을 말뚝 3으로 이동시키려면 우선 원판 C를 3으로 옮길 수 있어야 하고 원판 C를 이동시키려면 말뚝 3이 비어 있어야 한다.
2. 초기형태를 보면 원판 C는 원판 A, B가 우선 이동되지 않으면 움직일 수 없으므로 원판 A, B는 말뚝 3으로 이동되지 않는 것이 좋고 원판 C를 말뚝 3으로 이동시키기 위해 원판 A, B를 말뚝 2로 이동시킨다.
3. 원판 C를 말뚝 1로부터 말뚝 3으로 이동시키는 중요한 단계를 이룰 수 있고 이후 퍼즐의 나머지를 해결한다.

---

# 그래프

그래프를 이용한 상태공간 표현

1. 출발노드는 초기상태 묘사와 관련
2. 어떤 노드의 후계노드는 그 노드에 해당되는 상태묘사에 적용 가능한 연산자를 적용 -> 확장
3. 각 후계노드는 그의 부모노드를 가리키는 포인터를 가지고 있음
   이를 통해 최종적으로 목표노드를 찾았을 때 포인터를 이용하여 출발노드로부터 경로를 얻을 수 있음
4. 후계노드들은 목표노드인지 확인한다 -> 만일 목표노드가 아직 찾아지지 않았다면 노드를 확장시키는 작업이 계속됨

## 그래프 탐색

출발노드로부터 시작하여 정해진 순서대로 노드를 확장하는 과정에서 목표노드를 찾아내는 방법으로 풀이

트리는 그래프의 특별한 형태로 각 노드 오직 하나의 부모노드만 가지고 특별히 루트노드의 경우 부모노드가 없다.
따라서 출발노드는 루트노드가 된다.
그리고 탐색공간이 트리형태라고 가정하면 어떤 노드가 생성되었을 때 이 노드가 과거에 발생한 적이 없을 뿐 아니라 앞으로 결코 발생하지 않을 것이 확실해서
루트노드로부터 어떤 노드까지의 경로는 항상 유일하다.

### 맹목적 탐색

목표노드의 위치와는 무관한 순서로 노드를 확장하는 방법으로 소모적인 탐색
미래에 대한 어떤 정보도 사용하지 않는 탐색 방법

#### 깊이우선 탐색 DFS

해가 존재할 가능성이 있는 한 앞으로 계속 전진해서 탐색하는 방법
만일 그 과정에서 더이상 진행할 경로가 없으면 이전 상태 중 다른 경로를 선택할 수 있는 위치로 복귀하여 탐색을 계속한다.

탐색형태는 출발노드로부터 깊이가 가장 깊은 노드를 우선 탐색하는 형태가 된다.
즉 가장 최근에 생성한 노드를 가장 먼저 확장하는 것이다.

여기서 노드의 깊이는

1. 루트노드의 깊이는 0
2. 루트노드의 자손인 어떤 노드의 깊이는 이 노드의 부모의 깊이에 1을 더한 값

해가 없는 경로를 계속 탐색할 수도 있으므로 필요하다면 위의 노드로 되돌아가는 백트래킹을 할 수 있는 방도인 깊이 제한이 필요하다.
만익 어떤 노드가 깊이제한에 도달했는데도 해를 발견하지 못했다면 노드를 더이상 확장하지 않고 깊이제한을 넘지 않는 노드 중 가장 깊은 노드를 골라서 확장한다.

```
// 깊이우선 탐색 알고리즘
출발노드를 OPEN 에 삽입;
while not empty(OPEN) do {
   n = OPEN의 제일 앞 노드;
   n을 OPEN에서 제거 후 CLOSE에 넣음;

   if depth(n) > 깊이제한 then {
      노드 n을 확장하여 모든 후계노드를 생성;
      생성된 후계노드들에게 부모노드 n을 가리키는 포인터를 첨부;

      if 후계노드 중 목표노드가 존재 then {
         그 후계노드로부터 포인터를 역으로 추적하여 풀이경로 구성;
         return 탐색 성공;
      } else {
         후계노드를 OPEN의 앞에 넣음;
      }
   }
}
return 탐색 실패;
```

해당 알고리즘에서 OPEN 리스트는 노드를 꺼내는 순서는 삽입된 순서의 역순이라는 것, 즉 스택 구조인 것을 알 수 있다.

#### DFS 예 - 8 퍼즐 문제

```
// 초기 상태
2  8  3
1  6  4
7     5

// 목표 상태
1  2  3
8     4
7  6  5
```

상태를 변화시키는 것은 퍼즐의 한 조각을 빈칸으로 이동시키는 것으로 빈칸을 이동하는 것으로 바꾸어 생각하면,
빈칸을 상하좌우로 이동시키는 4 종류를 정의할 수 있다.
그래프의 노드를 확장하는 것은 그 노드에 빈칸의 상하좌우 이동연산자를 가하여 새로운 상태를 만들어내는 것이다.

깊이제한이 5라고 가정하면 OPEN에서 선택된 노드의 깊이가 5인 경우는 확장하지 않아야 한다.

#### 너비우선 탐색

생성된 순서에 따라 노드를 확장하는 방법

```
// 너비우선 탐색 알고리즘
출발노드를 OPEN 에 삽입;
while not empty(OPEN) do {
   n = OPEN의 제일 앞 노드;
   n을 OPEN에서 제거 후 CLOSE에 넣음;
   노드 n을 확장하여 모든 후계노드를 생성;
   생성된 후계노드들에게 부모노드 n을 가리키는 포인터를 첨부;

   if 후계노드 중 목표노드가 존재 then {
      그 후계노드로부터 포인터를 역으로 추적하여 풀이경로 구성;
      return 탐색 성공;
   } else {
      후계노드를 OPEN의 뒤에 넣음;
   }
}
return 탐색 실패;
```

OPEN으로부터 노드를 꺼내는 순서는 깊이우선 탐색과는 반대로 삽입된 순서와 동일함으로 큐 구조이다.
너비우선 탐색은 해가 존재한다면 출발노드에서 목표노드까지의 최단길이 경로를 찾는 것을 보장한다.
하지만 해가 존재하지 않는다면 유한 그래프의 경우에는 실패로 끝나고 무한 그래프의 경우에는 해를 찾지도 못하고 끝내지도 못한다.

#### 균일비용 탐색

출발노드로부터의 경로비용이 최소인 노드를 선택하여 확장하는 방법을 사용
탐색 과정에서 어떤 노드 n을 확장하여 m개의 후계노드가 생성되었을 때 후계노드를 ni 라고 하면 경로비용은
g(ni) = g(n) + C(n, ni) 와 같다.
\*g(n)은 출발노드 S로부터 노드 n까지의 경로비용이고 C(n, ni)는 노드 n에서 노드 ni로 이동하는데 소비되는 비용이다.

출발노드로부터 경로비용이 최소인 노드가 먼저 확장되므로 이 과정에서 발견된 목표노드는 최소의 비용이 소요되는 경로라고 할 수 있다.

```
// 균일비용 탐색 알고리즘
출발노드를 OPEN에 삽입, 출발노드의 경로비용은 0;
while not empty(OPEN) do {
   n = OPEN의 제일 앞 노드;
   n을 OPEN 에서 제거하여 CLOSE에 넣음;
   if n == 목표노드 then {
      노드 n으로부터 포인터를 역으로 추적하여 풀이경로 구성;
      return 탐색 성공;
   }
   노드 n을 확장하여 후계노드 n1, n2, ... nm을 생성;

   for i=1 to m do {
      ni에 부모노드인 n을 가리키는 포인터 첨부;
      ni의 경로비용 g(ni)를 계산; // g(ni) = g(n) + C(n, ni)

      if n(old)가 OPEN에 속하고 n(old) == ni then {
         if g(n(old)) > g(ni) then {
            n(old)를 ni로 대체; // 비용이 더 큰 기존 경로 제거
         } else {
            ni를 제거; // 비용이 더 큰 새로운 경로 제거
         }
      } else if n(old)가 CLOSE에 속하고 n(old) == ni then {
         ni를 제거; // g(n(old))는 무조건 g(ni)보다 작음
      } else {
         ni를 OPEN에 추가;
      }
   }
   OPEN을 경로비용 g의 오름차순으로 정렬;
}
return 탐색 실패;
```

균일비용 탐색에서 모든 C(n, ci)을 1이라고 하면 너비우선 탐색과 동일한 경로를 탐색하게 된다.

### 경험적 탐색

문제영역에서 사용할 수 있는 목표노드의 위치와 관련된 정보를 사용
항상 옳은 것은 아니지만 대부분 잘 맞는 경험에 의한 규칙을 이용한다.

탐색범위를 축소시키는 1가지 방법은 함수에 더 많은 정보를 재공하여 불필요한 후계노드의 생성을 막는 것이다.
그리고 OPEN에 저장되어 있는 노드를 선택할 때 어떠한 기준에 의해 보다 바람직한 노드를 먼저 선택하도록 하는 것이다.
선택 순서 조정을 위해 노드의 바람직한 정도를 평가하기 위한 척도가 필요한데 이를 평가함수라고 한다.

#### 언덕오르기 탐색

목표노드까지의 경로 비용 h(n)을 선택 기준으로 삼아 탐색하여 이때 h(n)이 최소인 노드를 선택하여 탐색해 나간다면 한번에 최소 비용 경로를 탐색할 수 있다.
정확한 h(n)값을 계산하는 것은 불가능하므로 경험적 지식에 의거한 h(n)의 예측치를 사용한다.

언덕오르기 탐색은 깊이우선 탐색과 유사하게 구성할 수 있지만 후계노드 가운데 다음 탐색할 노드를 선택할 때 h(n)에 의거하여 가장 유망한 노드를 선택한다.

```
출발노드를 OPEN에 삽입;
while not empty(OPEN) do {
   n = OPEN의 제일 앞 노드;
   n을 OPEN에서 제거하여 CLOSE에 넣음;
   노드 n을 확장하여 후계노드 n1, n2, ... nm을 생성;

   for i=1 to m do {
      ni에 부모노드인 n을 가리키는 포인터 첨부;
      if ni == 목표노드 then {
         ni로부터 포인터를 역으로 추적하여 풀이경로 구성;
         return 탐색성공;
      } else {
         ni의 평가함수 h(ni)을 계산;
      }
   }
   h(ni)가 작은 것이 앞에 오도록 ni를 OPEN에 추가;
}
return 탐색실패;
```

언덕오르기 탐색에선 현재상태까지 도달하는데 소비한 경로비용은 무시하고 앞으로 남은 목표까지의 비용만 고려한다는 점이 중요하다.

8-퍼즐에서 평가함수는 현재상태에서 목표상태와 비교했을 때 바른 위치에 놓여있지 않은 퍼즐의 개수를 세어주는 걸로 정한다.
언덕오르기 탐색에선 앞으로 남은 비용만 고려하므로 경제적인 경로를 놓칠 수 있어 최적경로 탐색을 보장하진 않는다.

##### 언덕오르기 탐색 예 - 계수최적화

어떤 사람이 초행길의 산을 등산하는 도중 짙은 안개를 만났을 때 지도도 없고 사람이 다닌 길도 없다고 가정한다.
나침반만을 이용하여 산의 정상에 오르고자 한다면 어떻게 해야할까?

이 문제에선 조정할만한 파라미터가 있고 파라미터값을 조정하여 문제의 상태가 개선되었는가를 판단하기 위한 방법이 존재한다.

1. 동서남북의 방향으로 이동 -> 파라미터는 위치
2. 이동하고자 하는 위치가 현재상태에 비해 높은 위치인지 판단 -> 상태는 높이
3. 현재 위치에서 주위를 둘러보아도 모두 현재위치보다 낮다면 그곳이 정상이라고 판단 -> 종료 조건

즉 언덕오르기 탐색을 이용하여 현재 위치를 기준으로 각 방향을 눈으로 확인할 수 있는 거리만큼 떨어진 곳의 높이를 판단한다. -> 노드의 확장
모든 위치가 현재위치보다 낮다면 그곳을 정상으로 판단한다. -> 목표상태 판단
현재위치가 정상이 아니라면 확인된 위치 중 가장 높은 곳으로 이동한다. -> 후계노드 선택
가장 가파르게 오르는 지점으로 이동하기 때문에 최급상승법이라고도 한다.

비용을 최소화하는 것과 같이 최솟값을 내는 파라미터를 찾는 것은 최급하강법이라고 한다.

##### 언덕오르기 탐색 문제점

1. 지역최대치 문제
   지역적으로 판단할 수밖에 없는 상황에서 전체적 상황을 고려하지 못하는 것에 기인하는 문제
   실제 정상이 있는 봉우리 주변에 그보다 얕은 작은 봉우리가 있는 경우, 작은 봉우리의 정상에 도달하면 더이상 현재 상태를 개선할 수 없는 것과 같다.
   -> 백트래킹할 수 있는 방법을 사용하여 보다 나은 해를 탐색해보는 방법으로 개선

2. 고원문제
   다음 진행할 방향을 찾는 경우 어느 방향으로 움직이더라도 현재 상태를 개선하지 못하는 평평한 영역이 산중턱에 존재하는 경우에 발생하는 문제
   -> 동일한 연산자를 여러 번 반복 적용한 결과를 토대로 진행방향을 결정하는 방법으로 개선

3. 능선문제
   어떠한 지점에서 진행할 다음 위치를 찾기 위해 동서남북의 4방향만 검사한다고 가정하면 4방향 모두 고도가 낮아지는 위치에선 더이상 진행할 방향이 없는 곳으로 판단하게 되는 문제
   -> 검사할 수 있는 방향(대각선)을 늘리거나 서로 다른 연산자들을 결합하여 적용해서 개선

#### 모의 담금질

언덕오르기 탐색은 평가함수가 줄어드는 방향으로는 움직이지 않기에 최적 경로가 될 수 없다.
이 문제를 해결하려는 시도 중 하나가 모의 담금질으로, 방대한 탐색공간에서 주어진 평가함수의 전역최적해를 구하기 위한 확률적인 경험적 접근 방법이다.
처음에는 세차게 흔들다가 서서히 약하게 흔드는 과정을 거쳐서 지역최소점에서 빠져나오고 전역최소점에 위치하도록 하는 원리이다.

```
// 모의 담금질
현재상태 <- 문제의 초기상태;

for i=1 to infinity do {
   T = temperature(t); // 시간에 따른 온도
   if T == 0 then {
      return 현재상태;
   }

   차기상태 = 현재상태의 후계노드 중 임의로 선택;
   E = h(차기상태) - h(현재상태); // 상태에 따른 평가함수의 차
   if E < 0 then { // 후계노드가 개선된 상태라면
      현재상태 = 차기상태;
   } else { // E >= 0이면 T->0 이므로 확률은 점점 0에 가까워짐
      확률 e^(-E/T)에 따라 차기상태를 현재상태로 선택;
   }
}
```

언덕오르기 탐색과 유사하나 후계노드 중 평가함수가 최소인 노드를 선택하는 대신 임의의 후계노드를 선택한다.
확률이 1보다 작은 값이 되도록 하여 선택한 노드가 얼마나 바람직하지 않은가 (E 크기)에 따라 줄어들도록 한다.

폭 넓은 응용 가능성과 최상에 가까운 해답을 얻을 수 있지만 많은 시간이 소비된다는 단점이 있다.

#### 최적우선 탐색 (best first search)

임의의 노드에 대한 평가함수값이 그 노드로부터 목표노드까지 도달하는 과정에 대한 비용의 예측치 또는 유망한 정도를 나타내는 값으로 정의되지만
OPEN 리스트가 관리되는 형태가 다르다.
OPEN 리스트 내의 모든 노드를 평가함숫값에 따라 정렬해둠으로써 가장 유망한 노드가 OPEN의 제일 앞에 위치하게 된다.

```
출발노드를 OPEN에 삽입;
while not empty(OPEN) do {
   n = OPEN의 제일 앞 노드;
   n을 OPEN에서 제거하여 CLOSE에 넣음;

   노드 n을 확장하여 후계노드 n1, n2, ... nm 을 생성;
   for i=1 to m do {
      ni에 부모노드인 n을 가리키는 포인터 첨부;
      if ni == 목표노드 then {
         ni로부터 포인터를 역으로 추적하여 풀이경로 구성;
         return  탐색성공;
      } else {
         ni의 평가함수 h(ni)를 계산;
         ni를 OPEN에 추가;
      }
   }
   OPEN을 평가함숫값의 오름차순으로 정렬; ***
}
return 탐색실패;
```

언덕오르기 탐색에선 현재 진행방향의 후계노드 중 가장 유망한 노드를 선택하여 확장하는 반면
최적우선 탐색에선 전체 노드를 대상으로 선택한다는 점이 다르다.

언덕오르기 탐색과 최적우선 탐색에선 어떠한 노드 n으로부터 목표노드까지 도달하기 위한 비용을 평가함수로 사용한다.
출발노드로부터 노드 n까지 도달하는데 소비한 비용은 고려하지 않기에 최적의 경로를 탐색하는 것은 보장하지 못한다.

#### A\* 알고리즘

출발노드에서 목표노드까지의 최적경로를 탐색

f(n) = g(n) + h(n)
*g(n): 출발노드로부터 노드 n까지의 경로비용 (이미 알고있는 비용)
*h(n): 노드 n으로부터 목표노드까지의 경로비용 (예상하기 어려운 비용 -> 경험적 지식 사용)

즉 f(n)은 출발노드에서 시작하여 노드 n을 거쳐 목표노드까지 도달하는 비용이므로 f(n)이 최소인 노드를 따라 탐색해 나가면 결국 최소비용 경로를 탐색할 수 있다.
h(n)의 예측이 얼마나 잘되었는가에 따라 효율적인 탐색이 이루어질 수 있다.

```
출발노드의 평가함숫값을 계산;
출발노드를 OPEN에 삽입;

while not empty(OPEN) do {
   n = OPEN 의 노드 중 평가함숫값이 최소인 노드; // 평가함숫값이 동일한 노드가 여러 개 있다면 임의로 선택하되 그중 목표노드가 있다면 우선 선택
   n을 OPEN에서 제거하여 CLOSE에 넣음;

   if n == 목표노드 then {
      그 후계노드로부터 포인터를 역으로 추적하여 풀이경로 구성;
      return 탐색성공;
   }

   노드 n을 확장하여 후계노드 n1, n2, ... nm 을 생성;
   for i=1 to m do {
      ni에 부모노드인 n을 가리키는 포인터 첨부;
      ni의 평가함수 f(ni)을 계산;
      if n(old)이 OPEN에 속하고 n(old) == ni then {
         // 중복노드 처리
         if f(n(old)) <= f(ni) then {
            ni를 제거;
         } else {
            n(old)를 OPEN에서 제거하고 ni를 OPEN에 추가;
         }
      } else if n(old)가 CLOSE에 속해있고 n(old) == ni then {
         // 중복노드 처리
         if f(n(old)) <= f(ni) then {
            ni를 제거;
         } else {
            n(old)의 부모 포인터를 n을 가리키도록 수정;
            n(old)의 평가함수를 f(ni)로 수정;
            n(old)의 모든 후계노드의 경로비용 g가 변했으므로 이를 수정; // 이 부분이 있어서 지금까지 어떤 경로를 거쳐왔는가를 함께 고려하여 전체 경로가 최적인 경로를 찾는다
         }
      } else {
         ni를 OPEN에 추가;
      }
   }
}
return 탐색실패;
```

---
