# 알고리즘

주어진 문제를 해결하기 위한 일련의 단계적인 처리 과정

- 일상적인 언어
- 순서도
- 의사 코드
- 프로그래밍 코드

# 알고리즘의 조건

1. 입출력: 0개 이상의 입력을 받아서 하나 이상의 출력을 생성해야 함
2. 명확성: 각 단계는 모호하지 않고 단순 명확해야 함
3. 유한성: 한정된 수의 단계를 거친 후 반드시 끝나야 함
4. 유효성: 모든 명령은 컴퓨터에서 수행할 수 있어야 함

# 알고리즘 설계

주어진 문제의 입출력 조건과 처리 조건 등을 고려하여 문제를 분석하고 이를 바탕으로 알고리즘을 설계

문제를 푸는 방법과 절차를 찾는 것에만 국한하지 않고 해결안의 정확성과 효율성을 분석하는 과정도 함께 이루어짐

문제와 함께 주어진 조건 등의 차이에 따라 문제해결에 적용되는 알고리즘이 달라질 수 있기에 알고리즘 설계에 있어 모든 문제나 대부분 문제에서 적용할 수 있는 범용적인 개념의 알고리즘 설계기법은 존재하지 않음

## 순차 탐색 알고리즘

"""
SequentialSearch(A[], n, key)

입력
A[0..n-1]
n 배열크기
key 탐색 키

출력
key가 배열 내 존재하면 해당 인덱스, 아니면 n

{
i = 0;
while (i < n && A[i] != key)
i = i + 1
return (i);
}

1. 첫 번째 숫자부터 확인하여 탐색 키와 동일한 숫자가 나올 때까지 비교

## 이진 탐색 알고리즘

입력데이터가 정렬된 경우 순차 탐색보다 효율적인 방식

"""
BinarySearch(A[], key, Left, Right)

A[Left..Right]
key 탐색 키

출력
key가 A[] 내에 존재하면 해당 인덱스, 아니면 -1 반환

{
if (Left > Right) return (-1);
Mid = floor((Left+Right)/2);
if (A[Mid] == key) return (Mid);
else if (key < A[Mid]) BinarySearch(A, key, Left, Mid-1);
else BinarySearch(A, key, Mid+1, Right);
}
"""

1. 주어진 배열에서 중앙 위치를 계산(Mid)
2. 중앙 위치의 값과 탐색 키를 비교하여 원하는 값이면 탐색을 종료
3. 그렇지 않다면 중앙 값과 탐색 키를 비교하여 이진 탐색을 순환 호출
4. 탐색 키가 중앙 값보다 작으면 정렬된 배열의 왼쪽 절반을 이진 탐색 순환 호출(Left~Mid-1)
5. 탐색 키가 중앙 값보다 크면 정렬된 배열의 오른쪽 절반을 이진 탐색 순환 호출(Mid+1~Right)

## 배열에서 가장 작은 값을 찾는 알고리즘

arr[] = {80, 50, 30, 10, 40, 90}
주어진 데이터에 대해 최솟값(/최댓값)을 찾는 기본적인 방법은 각 숫자를 차례대로 하나씩 비교하는 것

1. 입력 배열 중 첫 번째 데이터를 최솟값으로 지정
2. 배열에서 다음 숫자를 읽고 앞서 저장된 최솟값을 비교
3. 비교 후 더 작은 숫자를 최솟값으로 다시 지정
4. 배열에 처리할 데이터가 남아 있으면 2로 이동
5. 저장된 최솟값을 결과로 출력

## 오일러 경로

그래프의 모든 간선을 오직 한 번만 지나가는 경로를 찾는 문제

1. 각 정점의 차수가 홀수인 정점이 없거나 2개
2. 차수가 홀수인 정점이 2개인 경우 홀수 정점에서 시작해야 함
3. 홀수 정점이 0개인 경우 출발점과 도착점이 같은 오일러 경로가 됨 = 오일러 회로

## 데이크스트라 알고리즘

하나의 출발점을 기준으로 다른 모든 정점으로의 최단 경로를 구하는 문제

## 플로이드 알고리즘

임의의 두 도시 간 최단 경로를 찾는 문제
