# 알고리즘

주어진 문제를 해결하기 위한 일련의 단계적인 처리 과정

- 일상적인 언어
- 순서도
- 의사 코드
- 프로그래밍 코드

# 알고리즘의 조건

1. 입출력: 0개 이상의 입력을 받아서 하나 이상의 출력을 생성해야 함
2. 명확성: 각 단계는 모호하지 않고 단순 명확해야 함
3. 유한성: 한정된 수의 단계를 거친 후 반드시 끝나야 함
4. 유효성: 모든 명령은 컴퓨터에서 수행할 수 있어야 함

---

# 알고리즘 설계

주어진 문제의 입출력 조건과 처리 조건 등을 고려하여 문제를 분석하고 이를 바탕으로 알고리즘을 설계

문제를 푸는 방법과 절차를 찾는 것에만 국한하지 않고 해결안의 정확성과 효율성을 분석하는 과정도 함께 이루어짐

문제와 함께 주어진 조건 등의 차이에 따라 문제해결에 적용되는 알고리즘이 달라질 수 있기에 알고리즘 설계에 있어 모든 문제나 대부분 문제에서 적용할 수 있는 범용적인 개념의 알고리즘 설계기법은 존재하지 않음

# 알고리즘 설계기법

1. 욕심쟁이 방법 (greedy)
   선택 과정을 통해 해를 찾는데 전후 단계의 선택과 상관없이 단계마다 정해진 기준에 따라 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적 전략

- 희망적: 각 단계에서 전후 단계의 선택에 대해선 아무런 고려 없이 단지 현재 상태에서만 만족하는 최적해만을 선택하기에 국부적인 최적해가 항상 전체적인 최적해를 만들지 못할 수 있음을 의미
- 적용 범위가 제한적이라 해를 구할 수 없는 문제가 있을 수 있음
  ex. 거스름돈 문제, 배낭 문제, 최소 신장 트리 구하기(크루스칼, 프림 알고리즘), 최단 경로 구하기(데이크스트라 알고리즘)

* 거스름돈 문제
  가게에서 고객에게 돌려줄 거스름돈이 T원일 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제로 거스름돈의 액수를 초과하지 않으면서 단순히 액면가가 큰 동전부터 최대한 뽑아서 거스름돈을 만드는게 요지이다.

ex. 거스름돈이 780원일 때 고객에게 돌려줄 동전의 최소 개수(500, 100, 50, 10)
500 x 1 + 100 x 2 + 50 x 1 + 10 x 3
위의 결과로 거스름돈은 총 7개의 동전이 됨

하지만 650원을 500, 120, 100, 50, 10 동전으로 거슬러주고자 할 때 그리디 알고리즘으로는
500 x 1 + 120 x 1 + 10 x 3 으로 총 5개의 동전이 필요하지만
최적해는 500 x 1 + 100 x 1 + 50 x 1 로 총 3개의 동전을 사용하는 방법이다.

- 배낭 문제1

  - 배낭의 용량: M -> 10
  - 물체의 개수 n -> 4
  - 물체1의 이익과 무게(p1, w1) -> 18, 3
  - 물체2의 이익과 무게(p2, w2) -> 15, 5
  - 물체3의 이익과 무게(p3, w3) -> 12, 3
  - 물체4의 이익과 무게(p4, w4) -> 25, 4

  최대 용량 M인 하나의 배낭에 넣을 수 있는 n개의 물체가 있고 각 물체에는 무게 w와 그 물체를 배낭에 넣었을 때 얻을 수 있는 이익 p이 부여되어 있다고 가정한다. 배낭의 용량을 초과하지 않으면서 배낭에 들어있는 물체들의 이익의 합이 최대가 되도록 물체를 넣을 방법을 찾는 문제이다.
  여기서 물체를 쪼개서 넣을 수 있는가 없는가가 구분될 수 있는데 물체를 쪼개서 넣을 수 있다고 가정하고 생각한다.

  배낭의 용량을 조금 차지하면서 이익이 많은 물체부터 배낭에 욕심을 부려 최대한 넣는 과정을 반복한다. 물체를 통째로 넣을 수 없다면 남은 배낭의 용량에 맞게 물체를 쪼개어 넣어준다.

  각 단계의 선택 기준, 어떤 물체를 넣을 것인지 정하는 것이 중요하다. 물체를 쪼갤 수 있으므로 물체의 이익을 취하기보단 단위 무게당 이익을 계산한 뒤 최대가 되는 물체부터 배낭에 넣으면 최적해를 구할 수 있다.

  p/w => (18/3, 15/5, 12/3, 25/4) => 6, 3, 4, 6.25
  단위 무게당 이익

  위의 결과에 따라 물체 4, 1, 3, 2 순으로 배낭에 넣어준다.

  1. 물체 4 => 10-4 = 6
  2. 물체 1 => 6-3 => 3
  3. 물체 3 => 3-3 => 0
     -- 물체 2는 용량 부족으로 넣을 수 없다.
     즉 얻을 수 있는 최대 이익은 25+18+12 = 55가 된다.

- 배낭 문제2 - 물체를 쪼갤 수 없는 경우
  M = 10, n = 4
  p/w => (15/3, 20/5, 9/3, 14/4) => 5, 4, 3, 3.5
  물체를 넣는 순서: 물체1 -> 2 -> 4 -> 3

  1. 물체 1 => 10-3 = 7
  2. 물체 2 => 7-5 = 2
     물체를 쪼갤 수 있었다면 물체 4를 반으로 쪼개어 넣으면 되지만, 쪼갤 수 없다고 가정한 경우이므로 용량 2를 남기고 여기서 끝내게 된다.
     최대 이익은 15+20 = 35로 생각할 수 있지만 이것은 최적해가 아니다.
     실제 최대 이익은 물체 1, 3, 4를 넣어서 얻을 수 있는 15+9+14 = 38이 된다.

  \*\* 쪼갤 수 없는 유형의 배낭 문제를 0/1 배낭 문제라고 하며 이 문제는 그리디 방법으론 해결이 불가능하고 NP-완전 문제로 해결할 수 있다.

2. 분할 정복 (divide and conquer)
   순환적으로 문제를 푸는 하향식 접근 방법

주어진 문제의 입력을 더이상 나눌 수 없을 때까지 2개 이상의 작은 문제들로 순환적으로 분할하고, 분할된 작은 문제들을 각각 해결한 뒤 이들의 해를 결합하여 원래의 문제의 해를 구하는 방식이다.

각 순환 호출마다 분할, 정복, 결합의 세 가지 작업이 이루어진다.

- 분할: 주어진 문제의 입력을 여러 개의 작은 문제로 분할
- 정복: 작은 문제들을 순환적으로 분할
- 결합: 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구함

문제를 작게 쪼개는 것이 중요하고 작게 쪼개진 문제들은 원래의 문제에 비해 입력의 크기만 작아졌을 뿐 문제 자체는 원래 문제와 동일하고 서로 독립적이기에 각각의 작은 문제를 다시 순환적으로 분할하고 그 결과를 통합할 수 있게 된다.
ex. 퀵 정렬, 합병 정렬, 이진 탐색 등

- ex. 순환 알고리즘을 사용한 배열에서 탐색 키를 찾는 이진 탐색 과정
  A[] = {10, 15, 20, 25, 30, 35, 40, 45, 50}

key = 20
Left = 0
Right = 8
Mid = floor((Right+Left)/2)

A[Mid] = 30
key 보다 A[Mid]를 비교했을 때 key가 더 작으므로 배열의 왼쪽 절반에 해당하는 부분 배열로 대상을 줄여서 이진 탐색을 순환 호출한다.

A[] = {10, 15, 20, 25}
Left = 0
Right = 3
Mid = floor((Right+Left)/2)

A[Mid] = 15
key 가 A[Mid] 보다 크므로 배열의 오른쪽에 해당하는 부분 배열을 사용해서 이진 탐색을 순환 호출한다.

A[] = {20, 25}
Left = 2
Right = 3
Mid = floor((Right+Left)/2)

A[Mid] = 20
탐색 키 key와 A[Mid] 값이 같으므로 Mid = 2를 반환하고 탐색을 마친다.

위 과정은 분할정복 방법의 세 단계에 대응시켜보면

- 분할: 입력 크기가 n인 배열 중 가운데 원소를 기준으로 크기가 2/n인 왼쪽 부분배열과 오른쪽 부분배열로 분할
- 정복: 탐색 키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출하고 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출한다. 이진 탐색을 수행할 때마다 한쪽 부분배열은 대상에서 제외되므로 탐색 범위가 절반씩 줄어든다.
- 결합: 부분배열에 대해 이진 탐색의 결과가 직접 반환되므로 결과를 결합하는 과정은 필요 없음

3. 동적 프로그래밍 (dynamic programming)
   입력 크기가 가장 작은 부분 문제부터 해를 구하여 저장해 놓고 이를 이용하여 입력 크기가 보다 큰 문제의 해를 점진적으로 만들어 가는 상향식 접근 방법

- 작은 문제들은 분할정복 방법과 달리 독립적일 필요가 없음
- 한번 사용한 작은 문제의 해가 다음에 또 사용될 수 있으므로 이를 저장해두고 필요할 때마다 바로 사용

ex. 최솟값, 최댓값을 구하는 최적화 문제에 주로 사용, 모든 정점 쌍 간의 최단 경로를 구하는 플로이드 알고리즘

# 알고리즘 분석

## 정확성 분석

정확한 알고리즘이라면 유효한 입력이 주어졌을 때 유한 시간 내 정확한 결과를 생성해야 함.
수학적 기법을 사용하여 알고리즘이 예상한 대로 수행되는지에 대해 증명하는 과정

## 효율성 분석

알고리즘을 수행하는데 얼마나 많은 컴퓨터 자원이 필요한가를 평가하는 것 (주변장치, 수행 시간, 메모리 등)

주로 알고리즘을 수행하는데 시간적으로 얼마나 걸리는지와 공간적으로 얼마만큼의 메모리가 사용되는지 분석

1. 시간 복잡도
   알고리즘의 수행시간

- 실행부터 완료까지 걸리는 실제 수행시간의 측정을 통해 계산
- 사용하는 컴퓨터의 속도, 구현에 사용되는 프로그래밍 언어의 종류, 프로그램 작성법, 컴파일러 효율성 등 실행 환경에 따라 달라지므로 일반성이 없음
- 객관적인 측정방법으론 연산의 수행 횟수를 세는 방법을 사용하여 계산함
- 수행 횟수는 보통 하나의 문장으로 표현되므로 알고리즘의 각 문장이 수행되는 횟수의 합이 됨

2. 공간 복잡도
   알고리즘 수행에 필요한 총 메모리의 양

- 컴파일 과정에서 고정적으로 결정되는 정적인 공간과 실행 과정에서 동적 할당이나 함수 호출 등을 통해 동적으로 결정되는 공간

알고리즘 수행시간은 입력 크기와 입력 데이터의 상태에 따라 결과가 달라질 수 있고 입력 크기가 커질수록 그에 따라 수행시간은 당연히 증가하게 된다. 그래서 수행시간을 단순히 특정 입력 크기에 대한 단위 연산의 수행 횟수의 합으로 표현하기보단 입력 크기의 함수로 표현하게 된다.

알고리즘의 수행시간에 있어 입력되는 데이터의 상태에 따라 달라지기도 하는데, 정렬을 수행하는 경우 입력 데이터가 우연히 정렬된 상태로 제공되는 경우와 입력이 무작위 순서를 갖는 경우의 수행시간이 달라질 수 있다. 따라서 가장 이상적인 접근 방법은 가능한 모든 입력 상태에 대해 각각의 수행시간을 계산하고 이들의 평균/가중 평균을 취하는 것이다.
하지만 일반적으로 최선의 데이터 상태가 되는 것은 어려우므로 최악 수행시간을 알고리즘의 시간 복잡도의 척도로 많이 사용하는 것이다. 즉 어떠한 상태의 입력이 주어져도 이를 초과하는 수행시간은 걸리지 않는다는 것을 보장하므로 성능을 비교하기 용이하다.

### 수행시간 계산 예시

"""
SumAverage(A[], n)
입력: A[0..n-1], n : 입력 배열과 데이터의 개수
출력: 데이터의 합과 평균
{
sum = 0; -> 1회
i = 0; -> 1회
while (i < n) { -> n+1회
sum = sum + A[i]; -> n회
i = i + 1; -> n회
}
average = sum / n; -> 1회
print average, sum; -> 1회
}
"""
n은 입력 배열의 크기인 입력 데이터의 개수이다. 각 줄로 표현된 각 문장이 수행되는 횟수를 계산한 뒤 이를 모두 더한 값인 3n + 5 이 수행시간이 된다.

"""
DoubleIteration(n)
입력 n : 반복 횟수
출력: 이중 루프의 총 반복 횟수
{
count = 0; -> 1회
for (i=0; i<n; i++) { -> n+1회
for (j=0;j<n;j++) -> n+1회
count ++; -> n^2회
}
print count; -> 1회
}
"""
수행시간은 n^2+2n+4 가 된다.

## 점근성능

입력 크기가 커질수록 이에 비례하여 알고리즘의 수행시간은 증가하며 성능차이도 확연해진다. 그래서 입력 크기(n)가 작은 경우가 아닌 큰 상황을 전제로 알고리즘의 논리구조를 파악하여 성능을 분석하는 것이 바람직하다. 점근성능이란 입력 크기 n이 무한히 커짐으로써 결정되는 성능을 의미한다.

수행시간은 an+b, an^2+bn+c 등과 같은 다항식으로 표현되는데 상수 a,b,c 들은 연산의 종류와 알고리즘이 수행되는 컴퓨터 속도에 좌우되는 값으로 상수를 무시하고 입력 크기 n에 대한 차수만 고려하는 것이 일반적이다.

그리고 낮은 차수의 항들은 무시하고 최고차항만을 이용하여 수행시간을 더욱 간결히 표현해준다. 결국 점근성능으로 표현한다는 것은 수행시간의 다항식 함수에서 입력 크기가 충분히 커짐에 따라 함숫값에 가장 큰 영향을 미치는 차수를 찾는 것으로 다항식 함수에서 최고차항만을 계수 없이 취해서 단순화시킨 형태로 성능을 표현한다.

이처럼 점근성능을 표기하는 방법은 주로 빅오 표기, 빅오메가, 빅세타 표기를 사용한다.

1. 빅오 O()
   어떤 양의 상수 c,n0이 존재하여 모든 n>=n0에 대해
   f(n) <= c∙g(n)을 만족하면 f(n)=O(g(n))

- 점근 상한, 최악 수행시간

2. 빅오메가 Ω()
   어떤 양의 상수 c,n0 이 존재하여 모든 n>=n0에 대해
   f(n) >= c∙g(n)을 만족하면 f(n)=Ω(g(n))

   - 점근 하한, 최선의 수행시간

3. 빅세타 ⍬()
   어떤 양의 상수 c1,c2,n0 이 존재하여 모든 n>=n0에 대해
   c1∙g(n) <= f(n) <= c2∙g(n) 를 만족할 때
   -> f(n) = O(g(n)) = Ω(g(n)) 이면 f(n) = ⍬(g(n)) 이다.

   - 점근적 상한과 하한을 동시에 가지므로써 다른 표기법보다 성능을 정밀하게 나타낼 수 있음

ex. f(n) = 3n+3 / g(n) = n일 때 f(n)을 점근 표기법으로 나타내면,
c=5, n0=2 이면 n>=2 인 모든 n에 대해 f(n) <= 5∙g(n) 를 만족하므로 f(n) = O(g(n)) 인 O(n)이 된다.
c=3, n0=1 이면 n>=1 인 모든 n에 대해 f(n) >= 3∙g(n) 를 만족하므로 f(n) = Ω(g(n)) 인 Ω(n)이 된다.
f(n) = O(n) 이면서 Ω(n)이므로 f(n)=⍬(n)이기도 하다.

알고리즘의 시간 복잡도는 일반적으로 빅오 표기법을 사용한다.
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)

---

# 정렬

여러 개의 데이터가 구성된 리스트가 주어졌을 때 이 데이터들을 값의 크기 순서대로 재배치하는 것
데이터의 개수가 많을 때는 데이터에 다른 연산을 취하기 전 데이터를 정렬시켜 연산 속도를 높일 수 있다.

정렬을 수행하는 시점에 데이터가 어디에 저장되어 있는지 여부에 따라 구분된다.

1. 내부 정렬
   정렬할 데이터 전체를 주기억장치에 저장한 후 정렬을 수행하는 방식
2. 외부 정렬
   모든 데이터를 보조기억장치에 저장해 두고 그중 일부 데이터만 반복적으로 주기억장치로 옮겨와서 정렬을 수행하는 방식

## 안정적 정렬 알고리즘

동일한 값을 가지는 데이터가 여러 개 있을 때 정렬 전 상대적 위치가 정렬 후에도 그대로 유지되는 것이 보장될 때 (반대는 불안정적 정렬 알고리즘)

## 제자리(in place)

즉 정렬을 수행할 때 정렬 대상이 되는 입력 데이터가 저장되는 공간 이외에 얼마나 많은 메모리가 필요한지 나타내기 위해 제자리(in place) 개념이 사용된다. 그래서 입력 배열 외에 별도로 필요한 저장 공간이 상수 개를 넘지 않는 정렬 알고리즘

## 비교 기반의 정렬 알고리즘

정렬 과정에서 두 값 전체를 직접적으로 비교하여 어떤 값이 큰지, 작은지를 결정하는 방식으로 정렬을 수행하는 것
-> 값의 비교 횟수를 알고리즘의 수행시간으로 간주
ex. 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬은 O(n^2) 의 성능을 퀵 정렬, 합병 정렬, 힙 정렬은 O(nlogn)의 비교를 통해 정렬을 수행함. 계수 정렬, 기수 정렬, 버킷 정렬은 데이터 분포에 기반은 정보를 바탕으로 정렬을 수행하므로 자료의 이동 횟수를 수행시간으로 간주하여 O(n) 성능을 가진다.

## 기초적인 정렬 알고리즘 O(n^2)

### 선택 정렬

주어진 배열에서 가장 작은 값, 두 번째로 작은 값,.. 등 순서대로 선택해서 나열하는 방식

입력 배열 전체 A[0..n-1]에 대해서 최솟값을 찾아서 배열 A[0]에 위치시키면 A[0]은 정렬된 부분이고 A[1..n-1]은 미정렬 부분이 됨. 아직 정렬되지 않은 부분 A[1..n-1]에서 다시 최솟값을 찾아서 미정렬 부분의 첫 번째 데이터 A[1]과 최솟값의 위치를 교환하는 방식을 반복한다. 마지막에선 미정렬 부분 [n-2..n-1]의 2개의 데이터 중 최솟값을 찾아서 A[n-2]와 위치를 교환하여 정렬이 완료된다.

"""
SelectionSort(A[], n)
입력 A[0..n-1]
n: 입력 크기(데이터 수)
출력: A[0..n-1] 정렬된 배열
{
for (i=0;i<n-1;i++) { -> n-1번 반복
min = i;
for (j=i+1;j<n;j++)
if (A[min] > A[j])
min = j;
A[i]와 A[min]의 자리바꿈;
}
return (A);
}
"""
단계마다 미정렬 부분에서 최솟값을 찾고 첫 번째 데이터와의 위치를 교환하는 과정을 수행

- 선택 정렬은 비교적 간단하며 입력 크기 n이 작으면 효율적
- O(n^2)
  - 이중 루프로 구성됨
- 입력 데이터의 순서에 민감하지 않음
- 제자리 정렬 알고리즘
- 안정적 정렬 알고리즘은 아님

---

## 순차 탐색 알고리즘

"""
SequentialSearch(A[], n, key)

입력
A[0..n-1]
n 배열크기
key 탐색 키

출력
key가 배열 내 존재하면 해당 인덱스, 아니면 n

{
i = 0;
while (i < n && A[i] != key)
i = i + 1
return (i);
}

1. 첫 번째 숫자부터 확인하여 탐색 키와 동일한 숫자가 나올 때까지 비교

## 이진 탐색 알고리즘

입력데이터가 정렬된 경우 순차 탐색보다 효율적인 방식

"""
BinarySearch(A[], key, Left, Right)

A[Left..Right]
key 탐색 키

출력
key가 A[] 내에 존재하면 해당 인덱스, 아니면 -1 반환

{
if (Left > Right) return (-1);
Mid = floor((Left+Right)/2);
if (A[Mid] == key) return (Mid);
else if (key < A[Mid]) BinarySearch(A, key, Left, Mid-1);
else BinarySearch(A, key, Mid+1, Right);
}
"""

1. 주어진 배열에서 중앙 위치를 계산(Mid)
2. 중앙 위치의 값과 탐색 키를 비교하여 원하는 값이면 탐색을 종료
3. 그렇지 않다면 중앙 값과 탐색 키를 비교하여 이진 탐색을 순환 호출
4. 탐색 키가 중앙 값보다 작으면 정렬된 배열의 왼쪽 절반을 이진 탐색 순환 호출(Left~Mid-1)
5. 탐색 키가 중앙 값보다 크면 정렬된 배열의 오른쪽 절반을 이진 탐색 순환 호출(Mid+1~Right)

## 배열에서 가장 작은 값을 찾는 알고리즘

arr[] = {80, 50, 30, 10, 40, 90}
주어진 데이터에 대해 최솟값(/최댓값)을 찾는 기본적인 방법은 각 숫자를 차례대로 하나씩 비교하는 것

1. 입력 배열 중 첫 번째 데이터를 최솟값으로 지정
2. 배열에서 다음 숫자를 읽고 앞서 저장된 최솟값을 비교
3. 비교 후 더 작은 숫자를 최솟값으로 다시 지정
4. 배열에 처리할 데이터가 남아 있으면 2로 이동
5. 저장된 최솟값을 결과로 출력

## 오일러 경로

그래프의 모든 간선을 오직 한 번만 지나가는 경로를 찾는 문제

1. 각 정점의 차수가 홀수인 정점이 없거나 2개
2. 차수가 홀수인 정점이 2개인 경우 홀수 정점에서 시작해야 함
3. 홀수 정점이 0개인 경우 출발점과 도착점이 같은 오일러 경로가 됨 = 오일러 회로

## 데이크스트라 알고리즘

하나의 출발점을 기준으로 다른 모든 정점으로의 최단 경로를 구하는 문제

## 플로이드 알고리즘

임의의 두 도시 간 최단 경로를 찾는 문제
