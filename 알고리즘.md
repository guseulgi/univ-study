# 알고리즘

주어진 문제를 해결하기 위한 일련의 단계적인 처리 과정

- 일상적인 언어
- 순서도
- 의사 코드
- 프로그래밍 코드

# 알고리즘의 조건

1. 입출력: 0개 이상의 입력을 받아서 하나 이상의 출력을 생성해야 함
2. 명확성: 각 단계는 모호하지 않고 단순 명확해야 함
3. 유한성: 한정된 수의 단계를 거친 후 반드시 끝나야 함
4. 유효성: 모든 명령은 컴퓨터에서 수행할 수 있어야 함

# 알고리즘 설계

주어진 문제의 입출력 조건과 처리 조건 등을 고려하여 문제를 분석하고 이를 바탕으로 알고리즘을 설계

문제를 푸는 방법과 절차를 찾는 것에만 국한하지 않고 해결안의 정확성과 효율성을 분석하는 과정도 함께 이루어짐

문제와 함께 주어진 조건 등의 차이에 따라 문제해결에 적용되는 알고리즘이 달라질 수 있기에 알고리즘 설계에 있어 모든 문제나 대부분 문제에서 적용할 수 있는 범용적인 개념의 알고리즘 설계기법은 존재하지 않음

# 알고리즘 설계기법

1. 욕심쟁이 방법 (greedy)
   선택 과정을 통해 해를 찾는데 전후 단계의 선택과 상관없이 단계마다 정해진 기준에 따라 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적 전략

- 희망적: 각 단계에서 전후 단계의 선택에 대해선 아무런 고려 없이 단지 현재 상태에서만 만족하는 최적해만을 선택하기에 국부적인 최적해가 항상 전체적인 최적해를 만들지 못할 수 있음을 의미
- 적용 범위가 제한적이라 해를 구할 수 없는 문제가 있을 수 있음
  ex. 거스름돈 문제, 배낭 문제, 최소 신장 트리 구하기(크루스칼, 프림 알고리즘), 최단 경로 구하기(데이크스트라 알고리즘)

* 거스름돈 문제
  가게에서 고객에게 돌려줄 거스름돈이 T원일 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제로 거스름돈의 액수를 초과하지 않으면서 단순히 액면가가 큰 동전부터 최대한 뽑아서 거스름돈을 만드는게 요지이다.

ex. 거스름돈이 780원일 때 고객에게 돌려줄 동전의 최소 개수(500, 100, 50, 10)
500 x 1 + 100 x 2 + 50 x 1 + 10 x 3
위의 결과로 거스름돈은 총 7개의 동전이 됨

하지만 650원을 500, 120, 100, 50, 10 동전으로 거슬러주고자 할 때 그리디 알고리즘으로는
500 x 1 + 120 x 1 + 10 x 3 으로 총 5개의 동전이 필요하지만
최적해는 500 x 1 + 100 x 1 + 50 x 1 로 총 3개의 동전을 사용하는 방법이다.

- 배낭 문제

  - 배낭의 용량: M -> 10
  - 물체의 개수 n -> 4
  - 물체1의 이익과 무게(p1, w1) -> 18, 3
  - 물체2의 이익과 무게(p2, w2) -> 15, 5
  - 물체3의 이익과 무게(p3, w3) -> 12, 3
  - 물체4의 이익과 무게(p4, w4) -> 25, 4

  최대 용량 M인 하나의 배낭에 넣을 수 있는 n개의 물체가 있고 각 물체에는 무게 w와 그 물체를 배낭에 넣었을 때 얻을 수 있는 이익 p이 부여되어 있다고 가정한다. 배낭의 용량을 초과하지 않으면서 배낭에 들어있는 물체들의 이익의 합이 최대가 되도록 물체를 넣을 방법을 찾는 문제이다.
  여기서 물체를 쪼개서 넣을 수 있는가 없는가가 구분될 수 있는데 물체를 쪼개서 넣을 수 있다고 가정하고 생각한다.

  배낭의 용량을 조금 차지하면서 이익이 많은 물체부터 배낭에 욕심을 부려 최대한 넣는 과정을 반복한다. 물체를 통째로 넣을 수 없다면 남은 배낭의 용량에 맞게 물체를 쪼개어 넣어준다.

  각 단계의 선택 기준, 어떤 물체를 넣을 것인지 정하는 것이 중요하다. 물체를 쪼갤 수 있으므로 물체의 이익을 취하기보단 단위 무게당 이익을 계산한 뒤 최대가 되는 물체부터 배낭에 넣으면 최적해를 구할 수 있다.

2. 분할 정복 (divide and conquer)

3. 동적 프로그래밍 (dynamic programming)

## 순차 탐색 알고리즘

"""
SequentialSearch(A[], n, key)

입력
A[0..n-1]
n 배열크기
key 탐색 키

출력
key가 배열 내 존재하면 해당 인덱스, 아니면 n

{
i = 0;
while (i < n && A[i] != key)
i = i + 1
return (i);
}

1. 첫 번째 숫자부터 확인하여 탐색 키와 동일한 숫자가 나올 때까지 비교

## 이진 탐색 알고리즘

입력데이터가 정렬된 경우 순차 탐색보다 효율적인 방식

"""
BinarySearch(A[], key, Left, Right)

A[Left..Right]
key 탐색 키

출력
key가 A[] 내에 존재하면 해당 인덱스, 아니면 -1 반환

{
if (Left > Right) return (-1);
Mid = floor((Left+Right)/2);
if (A[Mid] == key) return (Mid);
else if (key < A[Mid]) BinarySearch(A, key, Left, Mid-1);
else BinarySearch(A, key, Mid+1, Right);
}
"""

1. 주어진 배열에서 중앙 위치를 계산(Mid)
2. 중앙 위치의 값과 탐색 키를 비교하여 원하는 값이면 탐색을 종료
3. 그렇지 않다면 중앙 값과 탐색 키를 비교하여 이진 탐색을 순환 호출
4. 탐색 키가 중앙 값보다 작으면 정렬된 배열의 왼쪽 절반을 이진 탐색 순환 호출(Left~Mid-1)
5. 탐색 키가 중앙 값보다 크면 정렬된 배열의 오른쪽 절반을 이진 탐색 순환 호출(Mid+1~Right)

## 배열에서 가장 작은 값을 찾는 알고리즘

arr[] = {80, 50, 30, 10, 40, 90}
주어진 데이터에 대해 최솟값(/최댓값)을 찾는 기본적인 방법은 각 숫자를 차례대로 하나씩 비교하는 것

1. 입력 배열 중 첫 번째 데이터를 최솟값으로 지정
2. 배열에서 다음 숫자를 읽고 앞서 저장된 최솟값을 비교
3. 비교 후 더 작은 숫자를 최솟값으로 다시 지정
4. 배열에 처리할 데이터가 남아 있으면 2로 이동
5. 저장된 최솟값을 결과로 출력

## 오일러 경로

그래프의 모든 간선을 오직 한 번만 지나가는 경로를 찾는 문제

1. 각 정점의 차수가 홀수인 정점이 없거나 2개
2. 차수가 홀수인 정점이 2개인 경우 홀수 정점에서 시작해야 함
3. 홀수 정점이 0개인 경우 출발점과 도착점이 같은 오일러 경로가 됨 = 오일러 회로

## 데이크스트라 알고리즘

하나의 출발점을 기준으로 다른 모든 정점으로의 최단 경로를 구하는 문제

## 플로이드 알고리즘

임의의 두 도시 간 최단 경로를 찾는 문제
